## 2. React Style and Conventions

React components should be focused, composition-friendly, idiomatic, and robust.

### High Level Goals

- Favor composition over inheritance or rigid templates.
- Make components small, single-responsibility, and easy to combine.
- Provide clear, stable public APIs (props and children).
- Avoid unnecessary re-renders and common hooks pitfalls.
- Include accessibility (a11y) and testability considerations.
- Prefer declarative over imperative APIs.

### Checklist For Final Review

- Does API support composition (children/render props/subcomponents)?
- Does this component rely on too many booleans for layout? (If yes, use `children`).
- Will this component trigger a re-render of its entire subtree on every prop change? (If yes, optimize state placement).
- Are controlled/uncontrolled modes clear and documented?
- Are effects and hooks using correct dependencies and including cleanup?
- Are callbacks memoized where they cross boundaries?
- Is ref forwarded and unknown props forwarded?
- Is accessibility addressed for interactive behavior?
- Are there unit tests covering main flows?

### Architect for Composition over Templates

- **Favor `children` and Slots:** Avoid creating "Mega-Components" with dozens of configuration props (e.g., `showIcon`, `headerText`, `footerButton`). Instead, use the `children` prop or named "slot" props (e.g., `icon={...}`, `footer={...}`) to allow the consumer to pass in their own elements.
- **Atomic Responsibility:** Breakdown UI into the smallest logical pieces.

### Prop API Design

- **Forwarding Refs:** Always forward refs on primitive-wrapping components to allow consumers to access the underlying DOM node for measurements or focus management.
- **Attribute Spreading:** Spread remaining props (`...rest`) onto the root element to ensure standard HTML attributes (like `aria-*`, `title`, or `id`) work out of the box.
- **Predictable Naming:** Follow standard React conventions: `on[Event]` for callbacks (e.g., `onSelect`) and `default[Value]` for uncontrolled initial states.

### State Management & "Thinking in React"

- **Lift State Up:** When multiple components need the same data, find the common ancestor and move the state there.
- **Controlled vs. Uncontrolled:** Design components to be "uncontrolled" by default (using internal state), but allow them to be "controlled" if a `value` and `onChange` prop are provided.
- **Derived State:** Never sync props to state. If a value can be calculated from props or existing state, calculate it during render (or wrap in `useMemo` if expensive).

### Performance & Re-render Optimization

- **Component Placement:** To prevent unnecessary re-renders of heavy UI trees, "move state down" to the smallest possible branch, or use "Component as Props" (passing elements as props) so they aren't affected by the parentâ€™s state changes.
- **Children Stability:** Remember that `children` is just a prop. If a parent re-renders, children will re-render unless they are memoized or passed from an ancestor that didn't re-render.
- **Avoid Inline Objects:** Discourage creating new object literals or arrow functions directly in props if the child component is wrapped in `React.memo`.

### Hook Best Practices & Pitfalls

- **Exhaustive Dependencies:** Always include every value used inside `useEffect`, `useCallback`, or `useMemo` in the dependency array. Do not lie to React.
- **Stable Callbacks:** Wrap functions passed to children in `useCallback` to prevent breaking `React.memo` optimizations downstream.
- **Cleanup Functions:** Every `useEffect` that sets a timer, subscription, or event listener must return a cleanup function to prevent memory leaks and race conditions.
- **Primitive Dependencies:** Prefer using primitive values in dependency arrays. If an object must be a dependency, memoize it with `useMemo`.

### Anti-patterns to avoid (explicitly)

- Mutating children or props directly.
- Relying on child order instead of keys/ids for identity.
- Passing new inline callbacks/objects to memoized children without need.
- Switching component between controlled and uncontrolled modes at runtime.
- Overusing context (single context for many unrelated values).
