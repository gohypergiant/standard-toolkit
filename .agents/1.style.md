## 1. JS/TS Style and Conventions

### Quick Reference

#### Do

- ‚úÖ Strongly validate external data
- ‚úÖ Employ defensive/negative-space programming
- ‚úÖ Use property-based testing
- ‚úÖ Return identity/zero elements instead of null/undefined
- ‚úÖ Use `const` over `let`
- ‚úÖ Keep functions pure and under 50 lines
- ‚úÖ Use early returns
- ‚úÖ Properly consider cache locality
- ‚úÖ Document all exports

#### Don't

- ‚ùå Rely solely on compiler/linter correctness
- ‚ùå Use default parameters
- ‚ùå Mutate passed references
- ‚ùå Use needless variable aliases
- ‚ùå Use spreading unless necessary
- ‚ùå Use unbounded loops
- ‚ùå Mock internal code
- ‚ùå Leave commented-out code
- ‚ùå Use `any` or `enum` in TypeScript

### General Rules

- Treat all warnings as errors; use strictest compiler/linter settings
- Use Linux line endings (`\n`)
- Aim for zero technical debt

### TypeScript Specifics

- Avoid `any` and `enum`; use explicit types and const maps
- Always provide a correct return type
- Prefer `type` over `interface`
- Use `type` when you want:
	- **True type aliases** (referential transparency)
	- **Type-level computation** (conditional types, mapped types)
	- **Algebraic composition** (unions, intersections)
	- **Phantom (Branded) types** for compile-time guarantees
	- **Exact type definitions** (no declaration merging)
	- **Functional programming patterns**
	- **Maximum correctness guarantees**
- Use `interface` only when you specifically need:
	- **Open/extensible object types** (intentional declaration merging)
	- **Class implementation contracts** (implements clause)
	- **Legacy compatibility** with existing interface-based APIs

### Naming Conventions

Use descriptive, meaningful names. Stick to complete words unless abbreviation is widely recognized (ID, URL, RCS).

```ts
// üõë Bad
const usrNm = /**/;
const a = /**/;
let data;

// ‚úÖ Good
const numberOfProducts = /**/;
const customerList = /**/;
const radarCrossSection = lookupCrossSection(entity.platformType);
```

**Units and qualifiers**: Append in descending order of significance.

```ts
// üõë Bad
const maxLatencyMs = /**/;

// ‚úÖ Good
const latencyMsMax = /**/;
const latencyMsMin = /**/;
```

**Booleans**: Prefix with `is` or `has`.

```ts
// üõë Bad
const visible = true;
const children = false;

// ‚úÖ Good
const isVisible = true;
const hasChildren = false;
```

### Functions

- Keep functions under 50 lines
- Limit parameters; prefer simple return types
- Never use default parameters‚Äîmake all values explicit at call site
- Use `function` keyword for pure functions
- Use arrow functions only for simple cases (< 3 instructions)

```ts
// üõë Bad - implicit defaults
const position = getPosition();

// ‚úÖ Good - explicit values
const position = getPosition(330);
```

### Control Flow

Use simple, flat control flow. Prefer early returns over nested conditionals. Branching (`if...else`, ternaries, `switch`) should be as low as possible.

```ts
// üõë Bad - nested structure
if (condition1) {
  if (condition2) {
    if (condition3) {
      result = /* something4 */;
    } else {
      result = /* something3 */;
    }
  } else {
    result = /* something2 */;
  }
} else {
  result = /* something1 */;
}

// ‚úÖ Good - early returns
if (!condition1) {
  return /* something1 */;
}

if (!condition2) {
  return /* something2 */;
}

if (!condition3) {
  return /* something3 */;
} 

return /* something4 */;
```

**Bounded iteration**: Set limits on all loops, queues, and data structures.

```ts
// üõë Bad - unbounded
while (true) {
  if (someCondition) break;
}

// ‚úÖ Good - bounded
for (const item of items) {
  // process item
}
```

### State Management

- Use `const` instead of `let` whenever possible. `let` should only be used if there is a valid performance reason
- Declare variables at smallest possible scope
- Never mutate passed references; create copies instead
- Centralize state manipulation in parent functions; keep leaf functions pure

```ts
// üõë Bad - reassignment
let color = src.substring(start + 1, end - 1);
color = color.replace(/\s/g, '');

// ‚úÖ Good - single assignment
const color = src.substring(start + 1, end - 1).replace(/\s/g, '');

// üõë Bad - mutation
function someFn(config) {
  config.left = 70;
}

// ‚úÖ Good - copy
function someFn(config) {
  const updated = { ...config, left: 70 };
}
```

**Conditionals with `let`**: Refactor to use ternary or early return.

```ts
// üõë Bad
let result;
if (validation.success) {
  result = primary.data.options.map(addIndex);
} else {
  result = fallback.data.options.map(addIndex);
}

// ‚úÖ Good
const config = validation.success ? primary : fallback;
const result = config.data.options.map(addIndex);
```

### Return Values

Always return a zero value (identity element) instead of `null` or `undefined`. This eliminates downstream branching.

```ts
// üõë Bad - requires downstream checks
function makeList(someVar) {
  if (!someVar) return;
  return toList(someVar);
}

function anotherFn() {
  const baseList = makeList(/*...*/);
  if (!Array.isArray(baseList)) return;
  return baseList.map((x) => {/*...*/});
}

// ‚úÖ Good - no checks needed
function makeList(someVar) {
  if (!someVar) return [];
  return toList(someVar);
}

function anotherFn() {
  return getSomeList(/*...*/).map((x) => {/*...*/});
}
```

## Safety

### Input Validation

Always validate and sanitize external data at system boundaries.

```ts
const AddressSchema = z.object({
  street: z.string(),
  city: z.string(),
  zipCode: z.string().length(5),
});

type Address = z.infer<typeof AddressSchema>;

const validateAddress = (userInput: Address) => {
  return AddressSchema.safeParse(userInput);
};
```

### Assertions

Assertions detect **programmer errors**. The only appropriate response to corrupted code is to crash.

```ts
function assert(condition: boolean, message?: string): asserts condition {
  if (!condition) {
    throw new Error(message);
  }
}
```

**Split compound assertions** for clarity:

```ts
// üõë Bad
assert(a && b);

// ‚úÖ Good
assert(a);
assert(b);
```

**Verify both positive and negative space**:

```ts
function calculateArea(width: number, height: number) {
  assert(width > 0, `Width must be > 0, received ${width}`);
  assert(height > 0, `Height must be > 0, received ${height}`);
}
```

**Include variable values in assertion messages**:

```ts
// üõë Bad
assert(index < items.length, 'Index error');

// ‚úÖ Good
assert(
  index < items.length,
  `Index out of bounds: index=${index}, items.length=${items.length}`
);
```

### Error Handling

Handle **all errors** explicitly. Test error-handling code thoroughly:

- **Negative Testing**: Deliberately introduce invalid inputs
- **Fault Injection**: Simulate system malfunctions or network issues
- **Recovery Testing**: Verify application can recover
- **Error Guessing**: Anticipate potential errors based on domain knowledge

### Error Messages

**For users**: Clear, empathetic, actionable.

```ts
// üõë Bad
alert('Error 500: Internal Server Error');

// ‚úÖ Good
alert(
  'We\'re having trouble connecting to our server.\n' +
  'Please check your internet connection and try again.'
);
```

**For developers**: Specific, include values, explain assumptions.

```ts
// üõë Bad
assert(typeof count === 'number', 'Type error');

// ‚úÖ Good
assert(
  typeof count === 'number',
  `Expected 'count' to be a number, but got type '${typeof count}'`
);
```

## Performance

Design for performance **from the start**. Optimize slowest resources first:

```
network >> disk >> memory >> CPU
```

Benchmark your assumptions before moving on.

### Reduce Branching

Use table lookups instead of conditionals for static values.

### Reduce Looping

Use `reduce` instead of chained array methods:

```ts
// üõë Bad - two iterations
const result = arr.filter(predicate).map(mapper);

// ‚úÖ Good - single iteration
const result = arr.reduce((acc, curr) =>
  predicate(curr) ? [...acc, mapper(curr)] : acc,
  []
);
```

Use `Set.has()` over `Array.includes()` for membership checks:

```ts
// üõë Bad - O(n)
const keys = Object.keys(someObj);
if (keys.includes(id)) { /**/ }

// ‚úÖ Good - O(1)
const keys = new Set(Object.keys(someObj));
if (keys.has(id)) { /**/ }
```

### Memoization

Use only when appropriate. Avoid memoizing trivial computations.

```ts
// üõë Bad - trivial computation
const ternMemo = memoize((pred) => pred ? 'Right!' : 'Wrong');

// ‚úÖ Good - direct computation
const result = test ? 'Right!' : 'Wrong';
```

### Batching

Batch operations to amortize costly processes, especially for I/O-bound operations.

### Predictable Execution

Write code with clear execution paths. Predictable code utilizes CPU caching and branch prediction more effectively.

## Documentation

All externally exposed APIs (exports) **must** have well-formed JSDoc comments. Internal utilities should also be documented.

### JSDoc Format

```ts
/**
 * <Description of the block>
 *
 * @template T - <Description of type parameter>
 * @param name - <Description of parameter>
 * @returns <Description if not obvious from types>
 *
 * @throws {ErrorType} <When this error is thrown>
 *
 * @remarks
 * <Additional context, e.g., "pure function">
 *
 * @example
 * ```<language>
 * // Usage example
 * const result = myFunction(arg);
 * ```
 *
 * @see {@link <link>} - <Reference description>
 */
```

### Required Tags

At minimum: `@param`, `@template` (if applicable), `@returns`, `@throws` (if applicable), `@example`.

Optional: `@see`/`@link`, `@remarks`, `@deprecated`.

### Example

```ts
/**
 * Clamps a number within the specified bounds.
 *
 * @param min - The lower bound to clamp to.
 * @param max - The upper bound to clamp to.
 * @param value - The number value to clamp to the given range.
 *
 * @throws {RangeError} Throws if min > max.
 *
 * @example
 * ```typescript
 * const value = clamp(5, 15, 10); // 10
 * const value = clamp(5, 15, 2);  // 5
 * const value = clamp(5, 15, 20); // 15
 * ```
 */
export function clamp(min: number, max: number, value: number): number {
  if (min > max) {
    throw new RangeError(`min (${min}) > max (${max})`);
  }
  
  return Math.max(min, Math.min(max, value));
}
```

### Comment Markers

Use "better comment" markers for non-docblock comments:

| Marker    | Usage                                      |
|-----------|--------------------------------------------|
| `TODO:`   | Future changes or unimplemented features   |
| `FIXME:`  | Known bugs or critical defects             |
| `HACK:`   | Workarounds or sub-optimal solutions       |
| `NOTE:`   | Important informational points             |
| `REVIEW:` | Areas requiring code review or scrutiny    |
| `PERF:`   | Performance bottlenecks or optimizations   |
| `DEBUG:`  | Temporary debugging code (remove later)    |
| `REMARK:` | General observations                       |

### Comments to Remove

- Commented-out code
- Edit history comments ("added", "removed", "changed")
- Comments restating what code clearly does

### Comments to Preserve

- Comments with markers (TODO, FIXME, etc.)
- Linter directives (`// eslint-disable`, `// @ts-ignore`)
- Business logic explanations
- Docblock comments

### Comment Placement

Move end-of-line comments to their own line above the code they describe.
