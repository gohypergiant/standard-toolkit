import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="Styling Guide" />

# Styling with the Design System

This guide covers how to style your application using the Design Toolkit's styling system.

## TailwindCSS

The Design Toolkit uses TailwindCSS as its styling foundation. If you're new to utility-first CSS, we recommend starting with [Tailwind documentation](https://tailwindcss.com/docs/styling-with-utility-classes). The fundamental concepts of utility classes are critical to being able to style in the Design Toolkit effectively.

However, the Core team has established opinionated patterns on how to keep code clean, readable and consistent. While many standard Tailwind classes work as expected, not all the Tailwind documentation will be relevant. The Design Toolkit extends Tailwind with custom semantic tokens for colors, spacing, radius, and typography. These custom classes ensure consistency with the design system and support light/dark mode theming out of the box. We've also made the choice to support css modules, despite the stance taken by the Tailwind.

### Colors

The Design Toolkit relies on the `@accelint/design-foundation` package that establishes an opinionated set of semantic color classes for background, foreground and outline colors (among other tokens). These colors ensure compatibility in our design and automatically adapt to light and dark mode. The tokens all have a prefix that will orient you to their intended use. They also target the css property that is relevant. For example, adding a `bg-surface-bold` semantic color class to a div will apply the `--bg-interactive-bold` css var to the `background-color` css property.

- **[Background colors](?path=/story/foundation-colors--background)** use the `bg-` prefix (e.g., `bg-surface-default`, `bg-accent-primary-bold`)
- **[Foreground colors](?path=/story/foundation-colors--foreground)** (text, icons) use the `fg-` prefix (e.g., `fg-primary-bold`, `fg-primary-muted`)
- **[Outline colors](?path=/story/foundation-colors--outline)** use the `outline-` prefix (e.g., `outline-static`, `outline-interactive`)

See the **[Foundation / Colors](?path=/story/foundation-colors--background)** stories in Storybook for the complete color palette with visual examples.

#### Prefer Semantic Colors

Under the hood, semantic classes map to our own primitive color palette based on the user's selected theme (light or dark). This means you can use semantic classes like `bg-surface-default` or `fg-primary-bold` throughout your codebase without conditional logic to guarantee support for light/dark mode theming:

```jsx
// ✅ Correct - semantic class adapts to theme automatically
<div className="bg-surface-default fg-primary-bold">
  Content
</div>

// ❌ Avoid - manual theme handling is unnecessary with semantic classes
<div className={theme === 'dark' ? 'bg-[black]' : 'bg-[white]'}>
  Content
</div>
```

This approach eliminates theme-checking ternaries scattered throughout the codebase and ensures consistent color usage across the application.

#### Primitives for Prototyping and Edge Cases

While most product experiences should comfortably live within the boundaries of the semantic colors, any mature application will inevitably include bespoke features that stretch beyond what the system has explicitly accounted for. In these rare cases, using the [primitive color tokens](https://github.com/gohypergiant/standard-toolkit/blob/main/packages/design-foundation/src/tokens/primitive.json) directly is also supported. While relying on primitives or one-off values fragments the experience, introduces visual inconsistencies, and increases long-term maintenance costs, this will provide you with a syntactically clean escape hatch. Exceptions should be rare and deliberate.

```jsx
// Supported and preferred
<div className="bg-surface-raised" />

// Ok, if prototyping or in rare edge cases
<div className="bg-neutral-300" />
<div className="fg-neutral-300" />
<div className="outline-neutral-300" />

```

### Spacing

The Design Toolkit uses a custom spacing scale instead of Tailwind's numeric scale to maintain consistency.

#### Prefer Semantic Spacing

| Token | Usage |
|-------|-------|
| `xxs` | Extra extra small |
| `xs` | Extra small |
| `s` | Small |
| `m` | Medium |
| `l` | Large |
| `xl` | Extra large |
| `xxl` | Extra extra large |
| `oversized` | Oversized spacing |

Use these with standard Tailwind spacing utilities (`p-`, `m-`, `gap-`, `w-`, `h-`, `size-`):

```jsx
<div className="p-m gap-l">        // padding: medium, gap: large
<div className="mt-xl mb-s">       // margin-top: xl, margin-bottom: small
<div className="size-xxl">         // width and height: xxl
```

See the **[Foundation / Spacing](?path=/story/foundation-spacing--spacing)** story in Storybook for exact pixel values.

#### Pixels for Prototyping and Edge Cases

While the spacing tokens should cover the majority of cases and are preferred, it is possible to use arbitrary spacing values. The `w-<number>` and `size-<number>` utilities are driven by the `--spacing` [theme variable](https://tailwindcss.com/docs/width#customizing-your-theme), which is set to `1px` in the Design Toolkit. That means when you need to express arbitrary spacing values, you can do a direct translation.

```jsx
// Preferred
<div className="gap-m" />

// Ok, if prototyping or in rare edge cases
// Represents a 10px gap
<div className="gap-10" />
```

### Radius

Use the custom border radius scale with the `rounded-` prefix:

| Class | Description |
|-------|-------------|
| `rounded-none` | No border radius |
| `rounded-small` | Small radius |
| `rounded-medium` | Medium radius |
| `rounded-large` | Large radius |
| `rounded-round` | Fully rounded (pill shape) |

See the **Foundation / Radius** story in Storybook for visual examples.

### Typography

The Design Toolkit provides two categories of typography classes: font families and text styles.

#### Font Families

Use these classes to set the font family:

```
font-primary              # Roboto - for body text, headers
font-display              # Roboto Mono - for code, labels, data
```

#### Text Styles

Text style classes (e.g., `text-header-xl`, `text-body-m`) set four CSS properties at once:

- `font-size`
- `font-weight`
- `letter-spacing`
- `line-height`

These values align directly with the text styles designers use in Figma, ensuring pixel-perfect implementation of designs.

See the **Foundation / Typography** stories in Storybook for the complete type scale.

### Outlines, Not Borders

DesignTK chooses to implement outlines instead of borders to make it so that the style doesn't impact box model dimensions. This way elements with or without a "border" are consistently sized based on content and padding alone. This also helps with sibling components rendering at the same size when their border styles may not match.

Do not implement borders, do implement outlines.

You might have rare instances where you do need to use a border. For example, if you need a line only at the top of a div. In this situation, use an outline semantic color variable directly to ensure consistency with the color system:

```jsx
// Preferred
<div className="outline outline-advisory-bold" />
<div className="outline-2 outline-advisory-bold" />

// Ok, if prototyping or in rare edge cases
<div className="border border-t-(--outline-advisory-bold)" />
```

### Responsive design

You can apply styles at specific breakpoints using prefixes like `sm:`, `md:`, `lg:`, and `xl:` using Tailwind's standard responsive utility classes as described in the [Tailwind responsive design documentation](https://tailwindcss.com/docs/responsive-design). All responsive utilities work exactly as documented in the official Tailwind guides.

## Overriding Design Toolkit Component Styles

Each Design Toolkit component exposes a prop for applying Tailwind utility classes as overrides.

### Simple Components: `className`

For simple components, use the `className` prop:

```jsx
import { Button } from '@accelint/design-toolkit';

<Button className="mt-l">
  Submit
</Button>
```

### Compound Components: `classNames`

For complex or compound components where you may want to override styles for multiple parts, use the `classNames` prop. This prop accepts an object with properties corresponding to different parts of the component:

```jsx
import { TextField } from '@accelint/design-toolkit';

<TextField
  label="Email"
  classNames={{
    field: 'w-full',
    label: 'fg-accent-primary-bold',
    input: {
      container: 'bg-surface-raised',
      input: 'text-body-l',
    },
    description: 'fg-primary-muted',
    error: 'fg-critical-bold',
  }}
/>
```

### Discovering Available Class Props

TypeScript is useful for discovering which parts of a component can be styled. Check the component's prop types for `className` or `classNames`:

```tsx
// TextField's classNames type
classNames?: {
  field?: string;
  label?: string;
  input?: {
    container?: string;
    sizer?: string;
    input?: string;
    clear?: string;
    prefix?: string;
    suffix?: string;
  };
  description?: string;
  error?: string;
};
```

Hover over the `classNames` prop in your IDE or check the component's type definitions to see available styling targets.

## Breaking Out of the System Constraints

While the Design Toolkit provides a styling system that should fit many use cases, there will likely be situations where you need to operate outside of the constraints it provides. Here are some common examples:

### Arbitrary Tailwind Classes

Tailwind supports [arbitrary values](https://tailwindcss.com/docs/adding-custom-styles#using-arbitrary-values) for one-off styles that don't exist in the theme. Use these sparingly and only when necessary:

```jsx
// Arbitrary value - use when no theme token exists
<div className="w-[327px]" />

// Arbitrary property - use for CSS properties without utility classes
<div className="[clip-path:circle(50%)]" />

// Referencing theme variables in arbitrary values
<div className="bg-(--fg-critical-bold)" />
```

When using arbitrary values, prefer referencing theme variables over hardcoding values:

```jsx
// ❌ Avoid hardcoding values that exist in the theme
<div className="[--my-font-size:12px]" />

// ✅ Reference theme variables instead
<div className="[--my-font-size:var(--body-m-size)]" />
```

If you find yourself reaching for arbitrary classes frequently, raise this to the core team so they can consider whether the design system should be extended to support your use case.

### Overriding Theme Variables

You can override theme variables in your application's global CSS file. You can also create application-specific variables in this manner.

Add overrides within the `@layer theme` block on `:root`. Use `@variant light` and `@variant dark` for theme-specific values:

**Example:** Override the accent color to use a custom seafoam palette instead of the default:

```css
/* globals.css */
@import '@accelint/design-foundation/styles';

/* override accent color */
@layer theme {
  :root {
    /* amorphous accent primitives */
    --seafoam-primary-50: #EBFFFA;
    --seafoam-primary-100: #B9FFEC;
    --seafoam-primary-200: #8AFFDF;
    --seafoam-primary-300: #5AFFD2;
    --seafoam-primary-400: #28F5BE;
    --seafoam-primary-500: #16D3A0;
    --seafoam-primary-600: #059971;
    --seafoam-primary-700: #01684C;
    --seafoam-primary-800: #014130;
    --seafoam-primary-900: #012A1F;

    @variant light {
      --bg-accent-primary-bold: var(--seafoam-primary-700);
      --bg-accent-primary-hover: var(--seafoam-primary-600);
      --bg-accent-primary-pressed: var(--seafoam-primary-800);
      --bg-accent-primary-muted: var(--seafoam-primary-100);

      --fg-accent-primary-bold: var(--seafoam-primary-600);
      --fg-accent-primary-hover: var(--seafoam-primary-400);
      --fg-accent-primary-pressed: var(--seafoam-primary-600);
      --fg-primary-muted: var(--seafoam-primary-800);

      --outline-accent-primary-bold: var(--seafoam-primary-600);
      --outline-accent-primary-hover: var(--seafoam-primary-200);
      --outline-accent-primary-pressed: var(--seafoam-primary-600);
    }

    @variant dark {
      --bg-accent-primary-bold: var(--seafoam-primary-700);
      --bg-accent-primary-hover: var(--seafoam-primary-600);
      --bg-accent-primary-pressed: var(--seafoam-primary-800);
      --bg-accent-primary-muted: var(--seafoam-primary-900);

      --fg-accent-primary-bold: var(--seafoam-primary-300);
      --fg-accent-primary-hover: var(--seafoam-primary-200);
      --fg-accent-primary-pressed: var(--seafoam-primary-600);

      --outline-accent-primary-bold: var(--seafoam-primary-300);
      --outline-accent-primary-hover: var(--seafoam-primary-200);
      --outline-accent-primary-pressed: var(--seafoam-primary-600);
    }
  }
}
```

Here, there are custom primitive colors that are then mapped the semantic variables that use those primitives. We recommend you take this approach in your own application for maximum flexibility. Generally, overriding theme variables should not be something engineers do without first consulting with their design partners.
