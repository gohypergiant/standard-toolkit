[
  {
    "$schema": "https://logicstamp.dev/schemas/context/v0.1.json",
    "position": "1/2",
    "type": "LogicStampBundle",
    "schemaVersion": "0.1",
    "entryId": "hooks/use-tree/actions/cache.ts",
    "depth": 2,
    "createdAt": "2026-01-05T14:24:26.192Z",
    "bundleHash": "uifb:db00a8e1894ad84a22adab12",
    "graph": {
      "nodes": [
        {
          "entryId": "hooks/use-tree/actions/cache.ts",
          "contract": {
            "type": "UIFContract",
            "schemaVersion": "0.3",
            "kind": "ts:module",
            "entryId": "hooks/use-tree/actions/cache.ts",
            "description": "cache - TypeScript module",
            "version": {
              "variables": [],
              "hooks": [],
              "components": [],
              "functions": [
                "addNodes",
                "addToParent",
                "addToRoot",
                "buildNode",
                "calculateVisibility",
                "delete",
                "deleteNode",
                "deriveVisibility",
                "get",
                "getAllKeys",
                "getAllNodes",
                "getNode",
                "insertNode",
                "moveNode",
                "moveNodes",
                "parentOrSibling",
                "rebuild",
                "removeFromParent",
                "removeFromRoot",
                "set",
                "setAllNodes",
                "setNode",
                "toTree",
                "traverse"
              ],
              "imports": ["../types", "@react-types/shared"]
            },
            "logicSignature": {
              "props": {},
              "emits": {}
            },
            "exports": "named",
            "semanticHash": "uif:dae57b44f59cc9495fce7c17",
            "fileHash": "uif:a66e3f0a0e2f6fc302b7d54c"
          },
          "codeHeader": null,
          "code": "// __private-exports\n/*\n * Copyright 2025 Hypergiant Galactic Systems Inc. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport type { Key } from '@react-types/shared';\nimport type { TreeNode } from '../types';\n\ntype CacheTreeNode<T> = Omit<TreeNode<T>, 'children'> & {\n  children?: Key[];\n};\n\n/**\n * This is a cache created only for performance reasons and is considered\n * to be only a temporary mirror of the data. The data is *always* correct\n * cache should be updated according to the data, only. If the data and\n * the cache do not match, the cache is invalidated and rebuilt.\n *\n * This will initialize once on load with data, then\n * updated with each tree operation.\n */\nexport class Cache<T> {\n  protected cache: { lookup: Map<Key, CacheTreeNode<T>>; roots: Key[] } = {\n    lookup: new Map(),\n    roots: [],\n  };\n\n  constructor(nodes: TreeNode<T>[] = []) {\n    this.rebuild(nodes);\n  }\n\n  /**\n   * Recursively creates the cache object from tree data\n   */\n  rebuild(\n    nodes: TreeNode<T>[],\n    lookup: Map<Key, CacheTreeNode<T>> = new Map(),\n    parentKey: Key | null = null,\n  ) {\n    nodes.forEach((node) => {\n      const { children, ...rest } = node;\n\n      lookup.set(node.key, {\n        isDisabled: false,\n        isExpanded: false,\n        isSelected: false,\n        isVisible: false,\n        isVisibleComputed: false,\n        ...rest,\n        parentKey,\n        ...(children ? { children: children.map((child) => child.key) } : {}),\n      });\n\n      if (node.children) {\n        this.rebuild(node.children, lookup, node.key);\n      }\n    });\n\n    const cache = { lookup, roots: nodes.map((node) => node.key) };\n\n    if (!parentKey) {\n      this.cache = cache;\n    }\n\n    this.deriveVisibility();\n    return cache;\n  }\n\n  protected get(key: Key) {\n    const node = this.cache.lookup.get(key);\n\n    if (node === undefined) {\n      throw new Error(`Key of ${key} does not exist in tree`);\n    }\n\n    return node;\n  }\n\n  protected set(key: Key, node: CacheTreeNode<T>) {\n    this.cache.lookup.set(key, node);\n  }\n\n  protected delete(key: Key) {\n    this.cache.lookup.delete(key);\n  }\n\n  protected addToParent(parentKey: Key, childKey: Key, idx: number) {\n    const parent = this.get(parentKey);\n    const child = this.get(childKey);\n    const index = Math.max(0, idx);\n\n    this.set(childKey, {\n      ...child,\n      parentKey,\n    });\n\n    const children = (parent.children ?? []).slice(0);\n\n    children.splice(index, 0, childKey);\n\n    this.set(parentKey, {\n      ...parent,\n      children,\n    });\n  }\n\n  protected addToRoot(key: Key, idx: number) {\n    const node = this.get(key);\n    const index = Math.max(0, idx);\n\n    this.set(key, {\n      ...node,\n      parentKey: null,\n    });\n\n    this.cache.roots.splice(index, 0, key);\n  }\n\n  protected removeFromParent(parentKey: Key, childKey: Key) {\n    const parent = this.get(parentKey);\n    const child = this.get(childKey);\n\n    this.set(childKey, {\n      ...child,\n      parentKey: null,\n    });\n\n    this.cache.lookup.set(parentKey, {\n      ...parent,\n      children: parent.children?.filter((key) => key !== childKey),\n    });\n  }\n\n  protected removeFromRoot(key: Key) {\n    const node = this.get(key);\n    const idx = this.cache.roots.indexOf(key);\n\n    if (idx >= 0) {\n      this.set(key, {\n        ...node,\n        parentKey: null,\n      });\n\n      this.cache.roots.splice(idx, 1);\n    }\n  }\n\n  protected parentOrSibling(target: Key | null, position: 'before' | 'after') {\n    let index: number;\n    let parentKey: Key | null = null;\n\n    if (target === null) {\n      index = position === 'before' ? 0 : this.cache.roots.length;\n    } else {\n      const targetNode = this.get(target);\n\n      if (targetNode.parentKey) {\n        const parent = this.get(targetNode.parentKey);\n\n        parentKey = parent.key;\n        index = parent.children?.indexOf(target) ?? 0;\n      } else {\n        index = this.cache.roots.indexOf(target);\n      }\n    }\n\n    return { parentKey, index };\n  }\n\n  protected traverse(key: Key) {\n    const node = this.get(key);\n\n    this.cache.lookup.set(key, {\n      ...node,\n      isVisibleComputed: this.calculateVisibility(key),\n    });\n\n    node.children?.map((child) => this.traverse(child));\n  }\n\n  protected calculateVisibility(key: Key) {\n    let current = this.get(key);\n    const ancestry = [current];\n\n    while (current.parentKey) {\n      const parent = this.get(current.parentKey);\n      if (parent) {\n        ancestry.push(parent);\n      }\n      current = parent;\n    }\n\n    return ancestry.every((n) => n.isVisible);\n  }\n\n  protected deriveVisibility() {\n    return this.cache.roots.map((key) => this.traverse(key));\n  }\n  /**\n   * Recursively builds a TreeNode from a key\n   *\n   * @param key\n   */\n  protected buildNode(key: Key): TreeNode<T> {\n    const node = this.get(key);\n\n    const children = (node.children ?? []).reduce(\n      (acc: TreeNode<T>[], child) => {\n        const childNode = this.cache.lookup.get(child);\n\n        if (childNode && childNode.parentKey === key) {\n          acc.push(this.buildNode(child));\n        }\n\n        return acc;\n      },\n      [],\n    );\n\n    return {\n      ...node,\n      children,\n    };\n  }\n\n  /**\n   * Builds a tree structure from cache\n   *\n   * TODO: optimization - rebuild only from change to root\n   * Rebuild only from the changed node up the tree to avoid\n   * rebuilding the entire tree\n   *\n   * @param deriveVisible boolean - if true, will recompute visibility for nodes based on ancestry\n   */\n  toTree(deriveVisible?: boolean): TreeNode<T>[] {\n    if (deriveVisible) {\n      this.deriveVisibility();\n    }\n    return this.cache.roots.map((key) => this.buildNode(key));\n  }\n\n  /**\n   * CACHE FUNCTIONS\n   * These manage cache operations. No cache operations should ever be done\n   * outside this file.\n   **/\n  getNode(key: Key): TreeNode<T> {\n    const node = this.get(key);\n\n    return {\n      ...node,\n      children: node.children?.map((key) => this.buildNode(key)),\n    };\n  }\n\n  getAllKeys() {\n    return this.cache.lookup.keys();\n  }\n\n  getAllNodes() {\n    return this.cache.lookup.values();\n  }\n\n  setNode(key: Key, node: TreeNode<T>) {\n    this.set(key, {\n      ...node,\n      children: (node.children ?? []).map((child) => child.key),\n    });\n  }\n\n  setAllNodes({ parentKey, children, ...rest }: Partial<TreeNode<T>>) {\n    for (const node of this.cache.lookup.values()) {\n      this.set(node.key, {\n        ...node,\n        ...rest,\n      });\n    }\n  }\n\n  deleteNode(key: Key) {\n    const node = this.cache.lookup.get(key);\n\n    if (!node) {\n      return;\n    }\n\n    // remove children\n    node.children?.map((key) => this.deleteNode(key));\n\n    // remove node from previous parent or root\n    node.parentKey\n      ? this.removeFromParent(node.parentKey, key)\n      : this.removeFromRoot(key);\n\n    // remove the actual node\n    this.delete(key);\n  }\n\n  addNodes(\n    target: Key | null,\n    nodes: TreeNode<T>[],\n    position: 'before' | 'after',\n  ) {\n    const { parentKey, index } = this.parentOrSibling(target, position);\n    const idx = index + (position === 'before' ? 0 : 1);\n\n    nodes.map((node, i) => this.insertNode(parentKey, node, idx + i));\n  }\n\n  insertNode(parentKey: Key | null, node: TreeNode<T>, idx: number) {\n    const { children, ...rest } = node;\n\n    this.set(node.key, {\n      isDisabled: false,\n      isExpanded: false,\n      isSelected: false,\n      isVisible: false,\n      isVisibleComputed: false,\n      ...rest,\n      parentKey,\n      ...(children ? { children: children.map((child) => child.key) } : {}),\n    });\n\n    node.children?.map((child, i) => this.insertNode(node.key, child, i));\n\n    parentKey === null\n      ? this.addToRoot(node.key, idx)\n      : this.addToParent(parentKey, node.key, idx);\n  }\n\n  moveNodes(target: Key | null, nodes: Set<Key>, position: 'before' | 'after') {\n    const { parentKey, index } = this.parentOrSibling(target, position);\n    const idx = index + (position === 'before' ? 0 : 1);\n\n    Array.from(nodes).map((key, i) => this.moveNode(parentKey, key, idx + i));\n  }\n\n  moveNode(parentKey: Key | null, key: Key, idx: number) {\n    const node = this.get(key);\n\n    // remove from previous parent\n    node.parentKey\n      ? this.removeFromParent(node.parentKey, key)\n      : this.removeFromRoot(key);\n\n    // add as child to new parent or root at position\n    parentKey\n      ? this.addToParent(parentKey, key, idx)\n      : this.addToRoot(key, idx);\n  }\n}\n"
        }
      ],
      "edges": []
    },
    "meta": {
      "missing": [],
      "source": "logicstamp-context@0.3.4"
    }
  },
  {
    "$schema": "https://logicstamp.dev/schemas/context/v0.1.json",
    "position": "2/2",
    "type": "LogicStampBundle",
    "schemaVersion": "0.1",
    "entryId": "hooks/use-tree/actions/index.ts",
    "depth": 2,
    "createdAt": "2026-01-05T14:24:26.192Z",
    "bundleHash": "uifb:ebc35443a5954223c03dfafe",
    "graph": {
      "nodes": [
        {
          "entryId": "hooks/use-tree/actions/index.ts",
          "contract": {
            "type": "UIFContract",
            "schemaVersion": "0.3",
            "kind": "react:hook",
            "entryId": "hooks/use-tree/actions/index.ts",
            "description": "index - Custom React hook",
            "version": {
              "variables": [],
              "hooks": ["useRef", "useUpdateEffect"],
              "components": [],
              "functions": ["useTreeActions"],
              "imports": [
                "../types",
                "./cache",
                "@react-aria/utils",
                "@react-types/shared",
                "client-only",
                "react"
              ]
            },
            "logicSignature": {
              "props": {},
              "emits": {}
            },
            "exports": "named",
            "prediction": ["Uses refs for DOM access or mutable values"],
            "semanticHash": "uif:c86563f3ea5159cc95bcab1f",
            "fileHash": "uif:e9f24ff230c6c42e49fb3619"
          },
          "codeHeader": null,
          "code": "/*\n * Copyright 2025 Hypergiant Galactic Systems Inc. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n'use client';\n\nimport 'client-only';\nimport { useUpdateEffect } from '@react-aria/utils';\nimport { useRef } from 'react';\nimport { Cache } from './cache';\nimport type { Key } from '@react-types/shared';\nimport type {\n  TreeActions,\n  TreeData,\n  TreeNode,\n  TreeNodeBase,\n  UseTreeActionsOptions,\n} from '../types';\n\n/**\n * Stateless hook that transforms tree data according to actions\n * it takes in nodes and returns a new version of the tree.\n *\n * Note: each operation returns the whole tree. Future iterations\n * might want to return only the changed portion of the tree.\n *\n * @returns {TreeActions<T>} Object containing all tree manipulation functions\n *\n * @example\n * ```tsx\n * const treeActions = useTreeActions({\n *   nodes: [\n *     {\n *       key: 'root',\n *       label: 'Root',\n *       children: [\n *         { key: 'child1', label: 'Child 1' },\n *         { key: 'child2', label: 'Child 2' }\n *       ]\n *     }\n *   ]\n * });\n *\n * // Use tree actions\n * const updatedTree = treeActions.insertAfter('child1', [\n *   { key: 'newChild', label: 'New Child' }\n * ]);Type T | undefined is not assignable to type T | undefined. Two different types with this name exist, but they are unrelated.\n * ```\n */\nexport function useTreeActions<T>({\n  nodes,\n}: UseTreeActionsOptions<T>): TreeActions<T> {\n  const cache = useRef(new Cache<T>(nodes)).current;\n\n  useUpdateEffect(() => {\n    cache.rebuild(nodes);\n  }, [nodes]);\n\n  /** GET NODE **/\n  function getNode(key: Key) {\n    return cache.getNode(key);\n  }\n\n  /** INSERT NODES **/\n  function insertAfter(\n    target: Key | null,\n    nodes: TreeNode<T>[],\n  ): TreeNode<T>[] {\n    cache.addNodes(target, nodes, 'after');\n\n    return cache.toTree(true);\n  }\n\n  function insertBefore(\n    target: Key | null,\n    nodes: TreeNode<T>[],\n  ): TreeNode<T>[] {\n    cache.addNodes(target, nodes, 'before');\n\n    return cache.toTree(true);\n  }\n\n  function insertInto(target: Key | null, nodes: TreeNode<T>[]): TreeNode<T>[] {\n    for (const node of nodes) {\n      cache.insertNode(target, node, 0);\n    }\n\n    return cache.toTree(true);\n  }\n\n  /** MOVE NODES **/\n  function moveAfter(target: Key | null, keys: Set<Key>): TreeNode<T>[] {\n    cache.moveNodes(target, keys, 'after');\n\n    return cache.toTree();\n  }\n\n  function moveBefore(target: Key | null, keys: Set<Key>): TreeNode<T>[] {\n    cache.moveNodes(target, keys, 'before');\n\n    return cache.toTree();\n  }\n\n  function moveInto(target: Key | null, keys: Set<Key>): TreeNode<T>[] {\n    for (const key of keys) {\n      cache.moveNode(target, key, 0);\n    }\n\n    return cache.toTree();\n  }\n\n  /** UPDATE NODES **/\n  function updateNode(\n    key: Key,\n    callback: (node: TreeNodeBase<T>) => TreeNodeBase<T>,\n  ): TreeNode<T>[] {\n    const node = cache.getNode(key);\n\n    cache.setNode(key, callback(node));\n\n    return cache.toTree(true);\n  }\n\n  /** REMOVE NODES **/\n  function remove(keys: Set<Key>): TreeNode<T>[] {\n    for (const key of keys.values()) {\n      cache.deleteNode(key);\n    }\n\n    return cache.toTree(true);\n  }\n\n  /** SELECTION **/\n  function onSelectionChange(keys: Set<Key>): TreeNode<T>[] {\n    unselectAll();\n\n    for (const key of keys) {\n      const node = cache.getNode(key);\n\n      cache.setNode(node.key, {\n        ...node,\n        isSelected: true,\n      });\n    }\n\n    return cache.toTree();\n  }\n\n  function selectAll(): TreeNode<T>[] {\n    cache.setAllNodes({ isSelected: true });\n\n    return cache.toTree();\n  }\n\n  function unselectAll(): TreeNode<T>[] {\n    cache.setAllNodes({ isSelected: false });\n\n    return cache.toTree();\n  }\n\n  /** EXPANSION **/\n  function onExpandedChange(keys: Set<Key>): TreeNode<T>[] {\n    collapseAll();\n\n    for (const key of keys) {\n      const node = cache.getNode(key);\n\n      cache.setNode(node.key, {\n        ...node,\n        isExpanded: true,\n      });\n    }\n\n    return cache.toTree();\n  }\n\n  function expandAll(): TreeNode<T>[] {\n    cache.setAllNodes({ isExpanded: true });\n\n    return cache.toTree();\n  }\n\n  function collapseAll(): TreeNode<T>[] {\n    cache.setAllNodes({ isExpanded: false });\n\n    return cache.toTree();\n  }\n\n  /** VISIBILITY **/\n  function onVisibilityChange(keys: Set<Key>): TreeData<T> {\n    hideAll();\n\n    for (const key of keys) {\n      const node = cache.getNode(key);\n      cache.setNode(node.key, {\n        ...node,\n        isVisible: true,\n      });\n    }\n    return cache.toTree(true);\n  }\n\n  function revealAll(): TreeNode<T>[] {\n    cache.setAllNodes({ isVisible: true });\n\n    return cache.toTree(true);\n  }\n\n  function hideAll(): TreeNode<T>[] {\n    cache.setAllNodes({ isVisible: false });\n\n    return cache.toTree(true);\n  }\n\n  return {\n    getNode,\n    insertAfter,\n    insertBefore,\n    insertInto,\n    moveAfter,\n    moveBefore,\n    moveInto,\n    remove,\n    updateNode,\n\n    // Expansion\n    collapseAll,\n    expandAll,\n    onExpandedChange,\n\n    // Selection\n    selectAll,\n    unselectAll,\n    onSelectionChange,\n\n    // Visibility\n    hideAll,\n    revealAll,\n    onVisibilityChange,\n  };\n}\n"
        }
      ],
      "edges": []
    },
    "meta": {
      "missing": [],
      "source": "logicstamp-context@0.3.4"
    }
  }
]
