[
  {
    "$schema": "https://logicstamp.dev/schemas/context/v0.1.json",
    "position": "1/1",
    "type": "LogicStampBundle",
    "schemaVersion": "0.1",
    "entryId": "components/query-builder/__fixtures__/example-configuration.ts",
    "depth": 2,
    "createdAt": "2026-01-05T14:24:25.591Z",
    "bundleHash": "uifb:4995a418dbcdb5793ce9b47a",
    "graph": {
      "nodes": [
        {
          "entryId": "components/query-builder/__fixtures__/example-configuration.ts",
          "contract": {
            "type": "UIFContract",
            "schemaVersion": "0.3",
            "kind": "ts:module",
            "entryId": "components/query-builder/__fixtures__/example-configuration.ts",
            "description": "example-configuration - Configuration module",
            "version": {
              "variables": ["defaultQuery", "fields"],
              "hooks": [],
              "components": [],
              "functions": [],
              "imports": ["react-querybuilder", "zod"]
            },
            "logicSignature": {
              "props": {},
              "emits": {}
            },
            "exports": {
              "named": ["defaultQuery", "fields"]
            },
            "semanticHash": "uif:89f713dcc626b87a0f1a74e4",
            "fileHash": "uif:16fbc62b2259efe06c782a5c"
          },
          "codeHeader": null,
          "code": "// __private-exports\n/*\n * Copyright 2025 Hypergiant Galactic Systems Inc. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport { z } from 'zod';\nimport type { Field } from 'react-querybuilder';\n\n/**\n * Represents sample field types and data for building a query.\n * These fields and their validators are for demonstration of capability and are not required for implementation.\n *\n */\nexport const fields: Field[] = [\n  {\n    name: 'AK_HIGH',\n    label: 'AK High',\n    type: 'i32',\n    inputType: 'number', // as in HTML input type <input type=\"number\">\n    operators: [\n      { name: '=', value: '=', label: 'is' } as const,\n      { name: '<', value: '<', label: 'less than' } as const,\n      { name: '>', value: '>', label: 'greater than' } as const,\n      { name: '<=', value: '<=', label: 'less than equal' } as const,\n      { name: '>=', value: '>=', label: 'greater than equal' } as const,\n      { name: 'between', value: 'between', label: 'between' } as const,\n      { name: 'in', value: 'in', label: 'in' } as const,\n    ],\n    validator: (rule) => ({\n      valid: z\n        .union([\n          z.coerce.number().int().gte(-2_147_483_648).lte(2_147_483_647),\n          z.tuple([\n            z.coerce.number().int().gte(-2_147_483_648).lte(2_147_483_647),\n            z.coerce.number().int().gte(-2_147_483_648).lte(2_147_483_647),\n          ]),\n        ])\n        .safeParse(rule.value).success,\n      reasons: ['Number must be in range.'],\n    }),\n  },\n  {\n    name: 'AK_LOW',\n    label: 'AK Low',\n    type: 'i32',\n    inputType: 'number', // as in HTML input type <input type=\"number\">\n    operators: [\n      { name: '=', value: '=', label: 'is' } as const,\n      { name: '<', value: '<', label: 'less than' } as const,\n      { name: '>', value: '>', label: 'greater than' } as const,\n      { name: '<=', value: '<=', label: 'less than equal' } as const,\n      { name: '>=', value: '>=', label: 'greater than equal' } as const,\n      { name: 'between', value: 'between', label: 'between' } as const,\n      { name: 'in', value: 'in', label: 'in' } as const,\n    ],\n    validator: (rule) => ({\n      valid: z\n        .union([\n          z.coerce.number().int().gte(-2_147_483_648).lte(2_147_483_647),\n          z.tuple([\n            z.coerce.number().int().gte(-2_147_483_648).lte(2_147_483_647),\n            z.coerce.number().int().gte(-2_147_483_648).lte(2_147_483_647),\n          ]),\n        ])\n        .safeParse(rule.value).success,\n      reasons: ['Number must be in range.'],\n    }),\n  },\n  {\n    name: 'COUNTRY',\n    label: 'Country',\n    type: 'str',\n    operators: [\n      { name: '=', value: '=', label: 'is' } as const,\n      { name: 'like', value: 'like', label: 'like' } as const,\n      { name: 'in', value: 'in', label: 'in' } as const,\n    ],\n    inputType: 'text',\n    validator: (rule) => ({\n      valid: z.string().min(1).safeParse(rule.value).success,\n      reasons: ['At least one character is required.'],\n    }),\n  },\n  {\n    name: 'NOTES',\n    label: 'Operator Notes',\n    type: 'str',\n    valueEditorType: 'textarea',\n  },\n  {\n    name: 'OPERSTATUS',\n    label: 'Is Operational',\n    type: 'bool',\n    defaultValue: false,\n    operators: [{ name: '=', value: '=', label: 'is' } as const],\n    valueEditorType: 'checkbox',\n  },\n  {\n    name: 'DONUTS',\n    label: 'Has Donuts',\n    type: 'bool',\n    operators: [{ name: '=', value: '=', label: 'is' } as const],\n    valueEditorType: 'switch',\n  },\n  {\n    name: 'SERVCITY',\n    label: 'Service City',\n    valueEditorType: 'select',\n    values: [\n      { name: 'Anchorage', label: 'Anchorage', value: 'Anchorage' },\n      { name: 'Juneau', label: 'Juneau', value: 'Juneau' },\n      {\n        name: 'Fairbanks',\n        label: 'Fairbanks',\n        value: 'Fairbanks',\n      },\n      { name: 'Sitka', label: 'Sitka', value: 'Sitka' },\n      { name: 'Montgomery', label: 'Montgomery', value: 'Montgomery' },\n      { name: 'Birmingham', label: 'Birmingham', value: 'Birmingham' },\n      {\n        name: 'Huntsville',\n        label: 'Huntsville',\n        value: 'Huntsville',\n      },\n      { name: 'Mobile', label: 'Mobile', value: 'Mobile' },\n    ],\n    type: 'str',\n    operators: [\n      { name: '=', value: '=', label: 'is' } as const,\n      { name: 'like', value: 'like', label: 'like' } as const,\n      { name: 'in', value: 'in', label: 'in' } as const,\n      { name: 'between', value: 'between', label: 'between' } as const,\n    ],\n  },\n  {\n    name: 'TYPE_CODE',\n    label: 'Type Code',\n    type: 'str',\n    operators: [{ name: '=', value: '=', label: 'is' } as const],\n    valueEditorType: 'radio',\n    values: [\n      { name: 'Heliport', label: 'Heliport', value: 'Heliport' },\n      { name: 'Aerodrome', label: 'Aerodrome', value: 'Aerodrome' },\n      { name: 'Unknown', label: 'Unknown', value: 'Unknown' },\n    ],\n    defaultValue: 'Aerodrome',\n  },\n  {\n    name: 'ESTABLISHED',\n    label: 'Established',\n    type: 'date',\n    operators: [\n      { name: 'equals', value: 'tequals', label: 'is' } as const,\n      { name: 'during', value: 'during', label: 'occurs between' } as const,\n      { name: 'before', value: 'before', label: 'ends before' } as const,\n      { name: 'after', value: 'after', label: 'starts after' } as const,\n      {\n        name: 'overlapped',\n        value: 'overlappedby',\n        label: 'starts during',\n      } as const,\n      { name: 'overlaps', value: 'toverlaps', label: 'ends during' } as const,\n    ],\n    inputType: 'date',\n    validator: (rule) => ({\n      valid: z\n        .union([\n          z.string().min(1),\n          z.tuple([z.string().min(1), z.string().min(1)]),\n        ])\n        .safeParse(rule.value).success,\n      reasons: ['At least one character is required.'],\n    }),\n  },\n  {\n    name: 'MAINTENANCE',\n    label: 'Maintenance',\n    type: 'datetime',\n    operators: [\n      { name: 'equals', value: 'tequals', label: 'is' } as const,\n      { name: 'during', value: 'during', label: 'occurs between' } as const,\n      { name: 'before', value: 'before', label: 'ends before' } as const,\n      { name: 'after', value: 'after', label: 'starts after' } as const,\n      {\n        name: 'overlapped',\n        value: 'overlappedby',\n        label: 'starts during',\n      } as const,\n      { name: 'overlaps', value: 'toverlaps', label: 'ends during' } as const,\n    ],\n    inputType: 'datetime-local', // mm/dd/yyyy hh:mm a\n    validator: (rule) => ({\n      valid: z\n        .union([\n          z.string().min(1),\n          z.tuple([z.string().min(1), z.string().min(1)]),\n        ])\n        .safeParse(rule.value).success,\n      reasons: ['At least one character is required.'],\n    }),\n  },\n  {\n    name: 'PEAK_TRAFFIC',\n    label: 'Peak Traffic',\n    type: 'time',\n    operators: [\n      { name: 'equals', value: 'tequals', label: 'is' } as const,\n      { name: 'during', value: 'during', label: 'occurs between' } as const,\n      { name: 'before', value: 'before', label: 'ends before' } as const,\n      { name: 'after', value: 'after', label: 'starts after' } as const,\n      {\n        name: 'overlapped',\n        value: 'overlappedby',\n        label: 'starts during',\n      } as const,\n      { name: 'overlaps', value: 'toverlaps', label: 'ends during' } as const,\n    ],\n    inputType: 'time', // hh:mm a\n    validator: (rule) => ({\n      valid: z\n        .union([\n          z.string().min(1),\n          z.tuple([z.string().min(1), z.string().min(1)]),\n        ])\n        .safeParse(rule.value).success,\n      reasons: ['At least one character is required.'],\n    }),\n  },\n] satisfies Field[];\n\n/**\n * Represents an initial query to populate the rulesets\n * to illustrate examples.\n */\nexport const defaultQuery = {\n  combinator: 'AND',\n  rules: [\n    { field: 'AK_HIGH', operator: '>', value: '10000' }, // i32\n    { field: 'AK_LOW', operator: 'between', value: ['1000', '5000'] }, // between\n    { field: 'COUNTRY', operator: 'like', value: 'Canada' }, //text\n    { field: 'NOTES', operator: 'contains', value: 'Clear skies...' }, // textarea\n    { field: 'SERVCITY', operator: 'like', value: 'Anchorage' }, // options with headers\n    { field: 'OPERSTATUS', operator: '=', value: false }, // bool\n    { field: 'DONUTS', operator: '=', value: true }, // switch\n    { field: 'TYPE_CODE', operator: '=', value: 'Aerodrome' }, // radio\n    {\n      field: 'ESTABLISHED',\n      operator: 'during',\n      value: ['2024-10-01', '2024-11-01'],\n    }, // date\n    {\n      field: 'PEAK_TRAFFIC',\n      operator: 'overlaps',\n      value: ['18:22:54', '19:22:54'],\n    }, // time\n    {\n      field: 'MAINTENANCE',\n      operator: 'overlapped',\n      value: ['2024-10-01T18:22:54', '2024-11-01T18:22:54'],\n    }, // datetime\n  ],\n};\n"
        }
      ],
      "edges": []
    },
    "meta": {
      "missing": [],
      "source": "logicstamp-context@0.3.4"
    }
  }
]
