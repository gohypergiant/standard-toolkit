[
  {
    "$schema": "https://logicstamp.dev/schemas/context/v0.1.json",
    "position": "1/3",
    "type": "LogicStampBundle",
    "schemaVersion": "0.1",
    "entryId": "components/slider/index.tsx",
    "depth": 2,
    "createdAt": "2025-12-22T18:06:43.842Z",
    "bundleHash": "uifb:f08704e4b7e5a00b336ede67",
    "graph": {
      "nodes": [
        {
          "entryId": "components/slider/index.tsx",
          "contract": {
            "type": "UIFContract",
            "schemaVersion": "0.3",
            "kind": "react:component",
            "entryId": "components/slider/index.tsx",
            "description": "index - Interactive component with internal state",
            "version": {
              "variables": ["DEBOUNCE_MS"],
              "hooks": [
                "useControlledState",
                "useEffect",
                "useMemo",
                "useRef",
                "useState"
              ],
              "components": [
                "AriaSlider",
                "AriaSliderTrack",
                "Fragment",
                "Input",
                "Label",
                "SliderInput",
                "SliderThumb",
                "Text",
                "Tooltip",
                "TooltipTrigger"
              ],
              "functions": [
                "Slider",
                "SliderInput",
                "hasLabeledMarkerAtValue",
                "normalizeMarkers",
                "normalizeValue",
                "snapToNearestMarker"
              ],
              "imports": [
                "../tooltip",
                "../tooltip/trigger",
                "./styles.module.css",
                "./types",
                "@accelint/design-foundation/lib/utils",
                "@react-stately/utils",
                "client-only",
                "react",
                "react-aria-components"
              ]
            },
            "logicSignature": {
              "props": {},
              "emits": {
                "onChange": {
                  "type": "function",
                  "signature": "(newValue) => void"
                },
                "onBlur": {
                  "type": "function",
                  "signature": "() => void"
                },
                "onChangeEnd": {
                  "type": "function",
                  "signature": "() => void"
                }
              },
              "state": {
                "localValue": "unknown"
              }
            },
            "exports": "named",
            "prediction": [
              "Has side effects managed by useEffect",
              "Uses memoization for performance optimization",
              "Uses refs for DOM access or mutable values"
            ],
            "style": {
              "styleSources": {
                "cssModule": "./styles.module.css",
                "cssDetails": {
                  "selectors": [
                    ".input",
                    ".inputs",
                    ".label",
                    ".marker",
                    ".markerDot",
                    ".markerLabel",
                    ".markers",
                    ".maxValue",
                    ".minValue",
                    ".slider",
                    ".thumb",
                    ".track",
                    ".trackBackground",
                    ".trackValue"
                  ],
                  "properties": [
                    "grid-template-columns",
                    "grid-template-rows",
                    "width"
                  ]
                },
                "inlineStyles": true
              }
            },
            "semanticHash": "uif:91e9275fb25fbfa21b679716",
            "fileHash": "uif:8b2a4f2610097f0f31f9efa6"
          },
          "codeHeader": null,
          "code": "/*\n * Copyright 2025 Hypergiant Galactic Systems Inc. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n'use client';\n\nimport 'client-only';\nimport { clsx } from '@accelint/design-foundation/lib/utils';\nimport { useControlledState } from '@react-stately/utils';\nimport {\n  type CSSProperties,\n  Fragment,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport {\n  Slider as AriaSlider,\n  SliderTrack as AriaSliderTrack,\n  composeRenderProps,\n  Input,\n  Label,\n  SliderThumb,\n  Text,\n} from 'react-aria-components';\nimport { Tooltip } from '../tooltip';\nimport { TooltipTrigger } from '../tooltip/trigger';\nimport styles from './styles.module.css';\nimport type { SliderMarker, SliderMarkersConfig, SliderProps } from './types';\n\nconst DEBOUNCE_MS = 500;\n\n/**\n * SliderInput - Internal component for debounced numeric input\n */\nfunction SliderInput({\n  className,\n  value,\n  min,\n  max,\n  disabled,\n  onChange,\n}: {\n  className?: string;\n  value: number;\n  min: number;\n  max: number;\n  disabled?: boolean;\n  onChange: (value: number) => void;\n}) {\n  const [localValue, setLocalValue] = useState(String(value));\n  const timeoutRef = useRef<ReturnType<typeof setTimeout>>(undefined);\n\n  // Sync local value when external value changes (e.g., from slider drag)\n  useEffect(() => {\n    setLocalValue(String(value));\n  }, [value]);\n\n  // Cleanup timeout on unmount\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  const commitValue = (inputValue: string) => {\n    const parsed = Number.parseFloat(inputValue);\n    if (Number.isNaN(parsed)) {\n      // Reset to min if invalid\n      setLocalValue(String(min));\n      onChange(min);\n    } else {\n      // Clamp to valid range\n      const clamped = Math.min(Math.max(parsed, min), max);\n      setLocalValue(String(clamped));\n      onChange(clamped);\n    }\n  };\n\n  const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const newValue = event.target.value;\n    setLocalValue(newValue);\n\n    // Clear existing timeout\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n\n    // Debounce the commit\n    timeoutRef.current = setTimeout(() => {\n      commitValue(newValue);\n    }, DEBOUNCE_MS);\n  };\n\n  const handleBlur = () => {\n    // Clear pending timeout and commit immediately\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    commitValue(localValue);\n  };\n\n  return (\n    <Input\n      className={className}\n      value={localValue}\n      disabled={disabled}\n      data-disabled={disabled || undefined}\n      onChange={handleChange}\n      onBlur={handleBlur}\n    />\n  );\n}\n\n/**\n * Normalizes the markers configuration into a consistent sorted array format\n */\nfunction normalizeMarkers(\n  markersConfig: SliderMarkersConfig | undefined,\n  min: number,\n  max: number,\n): SliderMarker[] {\n  if (markersConfig === undefined) {\n    return [];\n  }\n\n  // Number of evenly spaced markers\n  if (typeof markersConfig === 'number') {\n    if (markersConfig < 2) {\n      return [];\n    }\n    const step = (max - min) / (markersConfig - 1);\n    return Array.from({ length: markersConfig }, (_, i) => ({\n      value: min + step * i,\n    }));\n  }\n\n  // Array of numbers or marker objects - sort by value\n  return markersConfig\n    .map((item) => (typeof item === 'number' ? { value: item } : item))\n    .sort((a, b) => a.value - b.value);\n}\n\n/**\n * Snaps a value to the nearest marker (curried for use with map)\n * Assumes markers are sorted by value for early exit optimization\n */\nfunction snapToNearestMarker(markers: SliderMarker[]) {\n  return (value: number): number => {\n    const firstMarker = markers[0];\n    if (!firstMarker) {\n      return value;\n    }\n\n    let nearestValue = firstMarker.value;\n    let minDistance = Number.POSITIVE_INFINITY;\n\n    for (const marker of markers) {\n      const distance = Math.abs(value - marker.value);\n      if (distance < minDistance) {\n        minDistance = distance;\n        nearestValue = marker.value;\n      } else {\n        // Since markers are sorted, if distance increases we've passed the nearest\n        break;\n      }\n    }\n\n    return nearestValue;\n  };\n}\n\n/**\n * Checks if a marker with a label exists at the given value\n */\nfunction hasLabeledMarkerAtValue(\n  markers: SliderMarker[],\n  value: number,\n): boolean {\n  return markers.some(\n    (marker) =>\n      marker.value === value &&\n      marker.label !== undefined &&\n      marker.label !== '',\n  );\n}\n\n/**\n * Normalizes value to array format\n */\nfunction normalizeValue(\n  value: number | number[] | undefined,\n): number[] | undefined {\n  if (value === undefined) {\n    return undefined;\n  }\n  return Array.isArray(value) ? value : [value];\n}\n\n/**\n * Slider - An interactive range input component for numeric value selection\n *\n * Provides accessible slider functionality with optional input field integration,\n * flexible layouts, and comprehensive keyboard and mouse interaction support.\n * Perfect for settings, filters, or any numeric input requiring visual feedback.\n *\n * @example\n * // Basic slider\n * <Slider label=\"Volume\" defaultValue={50} />\n *\n * @example\n * // Slider with input field\n * <Slider label=\"Opacity\" defaultValue={50} showInput />\n *\n * @example\n * // Slider with labeled markers\n * <Slider\n *   label=\"Quality\"\n *   markers={[\n *     { value: 0, label: 'Low' },\n *     { value: 50, label: 'Medium' },\n *     { value: 100, label: 'High' },\n *   ]}\n *   showMarkerLabels\n * />\n *\n * @example\n * // Slider that snaps to marker values only\n * <Slider\n *   label=\"Rating\"\n *   markers={[0, 25, 50, 75, 100]}\n *   snapToMarkers\n * />\n */\nexport function Slider({\n  classNames,\n  defaultValue,\n  label: labelProp,\n  layout = 'grid',\n  markers: markersProp,\n  maxValue: maxValueProp = 100,\n  minValue: minValueProp = 0,\n  onChange,\n  onChangeEnd,\n  orientation = 'horizontal',\n  showInput,\n  showLabel = true,\n  showMarkerLabels = false,\n  showValueLabels = true,\n  snapToMarkers = false,\n  step: stepProp,\n  value: valueProp,\n  ...rest\n}: SliderProps) {\n  const normalizedMarkers = useMemo(\n    () => normalizeMarkers(markersProp, minValueProp, maxValueProp),\n    [markersProp, minValueProp, maxValueProp],\n  );\n\n  const shouldSnap = snapToMarkers && normalizedMarkers.length > 0;\n\n  // Normalize default value, applying snap if needed\n  const normalizedDefaultValue = useMemo(() => {\n    const normalized = normalizeValue(defaultValue);\n    if (shouldSnap && normalized) {\n      return normalized.map(snapToNearestMarker(normalizedMarkers));\n    }\n    return normalized ?? [minValueProp];\n  }, [defaultValue, shouldSnap, normalizedMarkers, minValueProp]);\n\n  // Use controlled state for value management\n  const [value, setValue] = useControlledState(\n    normalizeValue(valueProp),\n    normalizedDefaultValue,\n    onChange,\n  );\n\n  // Memoize marker percent calculations\n  const markerPercents = useMemo(() => {\n    const percents = new Map<number, number>();\n    const range = maxValueProp - minValueProp;\n    for (const marker of normalizedMarkers) {\n      percents.set(marker.value, ((marker.value - minValueProp) / range) * 100);\n    }\n    return percents;\n  }, [normalizedMarkers, minValueProp, maxValueProp]);\n\n  // Determine if min/max labels should be hidden\n  const hideMinValue =\n    !showValueLabels ||\n    (showMarkerLabels &&\n      hasLabeledMarkerAtValue(normalizedMarkers, minValueProp));\n  const hideMaxValue =\n    !showValueLabels ||\n    (showMarkerLabels &&\n      hasLabeledMarkerAtValue(normalizedMarkers, maxValueProp));\n\n  // Handle onChange - snap values when snapToMarkers is enabled\n  const handleChange = (values: number[]) => {\n    if (shouldSnap) {\n      setValue(values.map(snapToNearestMarker(normalizedMarkers)));\n    } else {\n      setValue(values);\n    }\n  };\n\n  // Handle onChangeEnd\n  const handleChangeEnd = (values: number[]) => {\n    if (shouldSnap) {\n      onChangeEnd?.(values.map(snapToNearestMarker(normalizedMarkers)));\n    } else {\n      onChangeEnd?.(values);\n    }\n  };\n\n  return (\n    <AriaSlider\n      {...rest}\n      className={composeRenderProps(classNames?.slider, (className) =>\n        clsx('group/slider', styles.slider, className),\n      )}\n      maxValue={maxValueProp}\n      minValue={minValueProp}\n      onChange={handleChange}\n      onChangeEnd={handleChangeEnd}\n      orientation={orientation}\n      step={stepProp}\n      value={value}\n      aria-label={showLabel ? undefined : labelProp}\n      data-layout={layout}\n    >\n      {({ state }) => (\n        <>\n          {showLabel && (\n            <Label className={clsx(styles.label, classNames?.label)}>\n              {labelProp}\n            </Label>\n          )}\n          {showInput && (\n            <div className={clsx(styles.inputs, classNames?.inputs)}>\n              {state.values.map((val, index) => (\n                <SliderInput\n                  key={`number-field-${index === 0 ? 'min' : 'max'}`}\n                  className={clsx(styles.input, classNames?.input)}\n                  value={val}\n                  min={minValueProp}\n                  max={maxValueProp}\n                  disabled={state.isDisabled}\n                  onChange={(newValue) => state.setThumbValue(index, newValue)}\n                />\n              ))}\n            </div>\n          )}\n          <AriaSliderTrack\n            className={composeRenderProps(classNames?.track, (className) =>\n              clsx(styles.track, className),\n            )}\n          >\n            <div\n              className={clsx(\n                styles.trackBackground,\n                classNames?.trackBackground,\n              )}\n            />\n            {/* Markers */}\n            {normalizedMarkers.length > 0 && (\n              <div className={clsx(styles.markers, classNames?.markers)}>\n                {normalizedMarkers.map((marker) => (\n                  <div\n                    key={`marker-${marker.value}`}\n                    className={clsx(styles.marker, classNames?.marker)}\n                    data-percent={markerPercents.get(marker.value)}\n                    aria-hidden='true'\n                  >\n                    <div\n                      className={clsx(styles.markerDot, classNames?.markerDot)}\n                    />\n                    {showMarkerLabels && marker.label && (\n                      <span\n                        className={clsx(\n                          styles.markerLabel,\n                          classNames?.markerLabel,\n                        )}\n                      >\n                        {marker.label}\n                      </span>\n                    )}\n                  </div>\n                ))}\n              </div>\n            )}\n            {state.values.map((_, index) => (\n              <Fragment key={`slider-${index === 0 ? 'min' : 'max'}`}>\n                <div\n                  className={clsx(styles.trackValue, classNames?.trackValue)}\n                  style={\n                    {\n                      '--track-value-start':\n                        state.values.length === 1\n                          ? 0\n                          : state.getThumbPercent(0),\n                      '--track-value-end': state.getThumbPercent(\n                        state.values.length === 1 ? 0 : 1,\n                      ),\n                    } as CSSProperties\n                  }\n                />\n                <TooltipTrigger\n                  isDisabled={showInput || state.isThumbDragging(index)}\n                >\n                  <SliderThumb\n                    index={index}\n                    className={composeRenderProps(\n                      classNames?.thumb,\n                      (className) => clsx(styles.thumb, className),\n                    )}\n                  />\n                  <Tooltip placement='top'>\n                    {state.getThumbValue(index)}\n                  </Tooltip>\n                </TooltipTrigger>\n              </Fragment>\n            ))}\n          </AriaSliderTrack>\n          <Text\n            slot='min'\n            className={clsx(styles.minValue, classNames?.minValue)}\n            hidden={hideMinValue}\n          >\n            {minValueProp}\n          </Text>\n          <Text\n            slot='max'\n            className={clsx(styles.maxValue, classNames?.maxValue)}\n            hidden={hideMaxValue}\n          >\n            {maxValueProp}\n          </Text>\n        </>\n      )}\n    </AriaSlider>\n  );\n}\n"
        }
      ],
      "edges": []
    },
    "meta": {
      "missing": [
        {
          "name": "AriaSlider",
          "reason": "No contract found (third-party or not scanned)",
          "referencedBy": "components/slider/index.tsx"
        },
        {
          "name": "AriaSliderTrack",
          "reason": "No contract found (third-party or not scanned)",
          "referencedBy": "components/slider/index.tsx"
        },
        {
          "name": "Fragment",
          "reason": "No contract found (third-party or not scanned)",
          "referencedBy": "components/slider/index.tsx"
        },
        {
          "name": "Input",
          "reason": "No contract found (third-party or not scanned)",
          "referencedBy": "components/slider/index.tsx"
        },
        {
          "name": "Label",
          "reason": "No contract found (third-party or not scanned)",
          "referencedBy": "components/slider/index.tsx"
        },
        {
          "name": "SliderThumb",
          "reason": "No contract found (third-party or not scanned)",
          "referencedBy": "components/slider/index.tsx"
        },
        {
          "name": "Text",
          "reason": "No contract found (third-party or not scanned)",
          "referencedBy": "components/slider/index.tsx"
        },
        {
          "name": "Tooltip",
          "reason": "No contract found (third-party or not scanned)",
          "referencedBy": "components/slider/index.tsx"
        },
        {
          "name": "TooltipTrigger",
          "reason": "No contract found (third-party or not scanned)",
          "referencedBy": "components/slider/index.tsx"
        }
      ],
      "source": "logicstamp-context@0.3.2"
    }
  },
  {
    "$schema": "https://logicstamp.dev/schemas/context/v0.1.json",
    "position": "2/3",
    "type": "LogicStampBundle",
    "schemaVersion": "0.1",
    "entryId": "components/slider/slider.stories.tsx",
    "depth": 2,
    "createdAt": "2025-12-22T18:06:43.844Z",
    "bundleHash": "uifb:3bbf28e41f7bdf9d040fb48e",
    "graph": {
      "nodes": [
        {
          "entryId": "components/slider/slider.stories.tsx",
          "contract": {
            "type": "UIFContract",
            "schemaVersion": "0.3",
            "kind": "react:component",
            "entryId": "components/slider/slider.stories.tsx",
            "description": "slider.stories - Presentational component",
            "version": {
              "variables": [
                "Default",
                "DisabledWithMarkers",
                "Range",
                "RangeWithInput",
                "RangeWithMarkers",
                "RangeWithSnap",
                "SnapToLabeledMarkers",
                "SnapToMarkers",
                "SnapToUnevenMarkers",
                "VerticalWithMarkers",
                "WithDetailedLabeledMarkers",
                "WithEvenlySpacedMarkers",
                "WithInput",
                "WithLabeledMarkers",
                "WithSpecificMarkerValues",
                "meta"
              ],
              "hooks": [],
              "components": ["Slider"],
              "functions": [],
              "imports": ["./index", "@storybook/react-vite"]
            },
            "logicSignature": {
              "props": {},
              "emits": {}
            },
            "exports": {
              "named": [
                "Default",
                "DisabledWithMarkers",
                "Range",
                "RangeWithInput",
                "RangeWithMarkers",
                "RangeWithSnap",
                "SnapToLabeledMarkers",
                "SnapToMarkers",
                "SnapToUnevenMarkers",
                "VerticalWithMarkers",
                "WithDetailedLabeledMarkers",
                "WithEvenlySpacedMarkers",
                "WithInput",
                "WithLabeledMarkers",
                "WithSpecificMarkerValues"
              ]
            },
            "style": {
              "styleSources": {
                "tailwind": {
                  "categories": {
                    "sizing": ["h-[300px]", "size-[400px]", "w-[200px]"]
                  },
                  "classCount": 3
                }
              }
            },
            "semanticHash": "uif:e0dcbcdf287fedd468634ab8",
            "fileHash": "uif:63fdf9274aee88add3a2212a"
          },
          "codeHeader": null,
          "code": "/*\n * Copyright 2025 Hypergiant Galactic Systems Inc. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport { Slider } from './index';\nimport type { Meta, StoryObj } from '@storybook/react-vite';\n\nconst meta = {\n  title: 'Components/Slider',\n  component: Slider,\n  args: {\n    defaultValue: 30,\n    layout: 'grid',\n    label: 'Opacity',\n    maxValue: 100,\n    minValue: 0,\n    orientation: 'horizontal',\n    showInput: false,\n    showLabel: true,\n    showValueLabels: true,\n    isDisabled: false,\n  },\n  argTypes: {\n    layout: {\n      control: 'select',\n      options: ['grid', 'stack'],\n    },\n    orientation: {\n      control: 'select',\n      options: ['horizontal', 'vertical'],\n    },\n    markers: {\n      control: 'object',\n      description: 'Configure discrete marker points on the slider track',\n    },\n    showMarkerLabels: {\n      control: 'boolean',\n      description: 'Whether to show labels on markers',\n    },\n    snapToMarkers: {\n      control: 'boolean',\n      description: 'When true, the slider can only be set to marker values',\n    },\n    showInput: {\n      control: 'boolean',\n      description: 'Whether to display numeric input fields',\n    },\n    showValueLabels: {\n      control: 'boolean',\n      description: 'Whether to display min/max value labels',\n    },\n  },\n} satisfies Meta<typeof Slider>;\n\nexport default meta;\ntype Story = StoryObj<typeof meta>;\n\nexport const Default: Story = {\n  render: ({ ...args }) => {\n    return (\n      <div className='size-[400px]'>\n        <Slider {...args} />\n      </div>\n    );\n  },\n};\n\nexport const WithInput: Story = {\n  args: {\n    defaultValue: 50,\n    label: 'Volume',\n    showInput: true,\n  },\n  render: ({ ...args }) => {\n    return (\n      <div className='size-[400px]'>\n        <Slider {...args} />\n      </div>\n    );\n  },\n};\n\nexport const Range: Story = {\n  args: {\n    defaultValue: [20, 80],\n  },\n  render: ({ ...args }) => {\n    return (\n      <div className='size-[400px]'>\n        <Slider {...args} />\n      </div>\n    );\n  },\n};\n\nexport const RangeWithInput: Story = {\n  args: {\n    defaultValue: [20, 80],\n    label: 'Price Range',\n    showInput: true,\n  },\n  render: ({ ...args }) => {\n    return (\n      <div className='size-[400px]'>\n        <Slider {...args} />\n      </div>\n    );\n  },\n};\n\nexport const WithEvenlySpacedMarkers: Story = {\n  args: {\n    defaultValue: 50,\n    label: 'Volume',\n    markers: 5,\n  },\n  render: ({ ...args }) => {\n    return (\n      <div className='size-[400px]'>\n        <Slider {...args} />\n      </div>\n    );\n  },\n};\n\nexport const WithSpecificMarkerValues: Story = {\n  args: {\n    defaultValue: 50,\n    label: 'Temperature (Â°F)',\n    markers: [0, 32, 72, 100],\n  },\n  render: ({ ...args }) => {\n    return (\n      <div className='size-[400px]'>\n        <Slider {...args} />\n      </div>\n    );\n  },\n};\n\nexport const WithLabeledMarkers: Story = {\n  args: {\n    defaultValue: 50,\n    label: 'Quality',\n    markers: [\n      { value: 0, label: 'Low' },\n      { value: 50, label: 'Medium' },\n      { value: 100, label: 'High' },\n    ],\n    showMarkerLabels: true,\n  },\n  render: ({ ...args }) => {\n    return (\n      <div className='size-[400px]'>\n        <Slider {...args} />\n      </div>\n    );\n  },\n};\n\nexport const WithDetailedLabeledMarkers: Story = {\n  args: {\n    defaultValue: 25,\n    label: 'Video Quality',\n    markers: [\n      { value: 0, label: '480p' },\n      { value: 25, label: '720p' },\n      { value: 50, label: '1080p' },\n      { value: 75, label: '1440p' },\n      { value: 100, label: '4K' },\n    ],\n    showMarkerLabels: true,\n  },\n  render: ({ ...args }) => {\n    return (\n      <div className='size-[400px]'>\n        <Slider {...args} />\n      </div>\n    );\n  },\n};\n\nexport const VerticalWithMarkers: Story = {\n  args: {\n    defaultValue: 50,\n    label: 'Brightness',\n    orientation: 'vertical',\n    markers: [\n      { value: 0, label: 'Min' },\n      { value: 50, label: '50%' },\n      { value: 100, label: 'Max' },\n    ],\n    showMarkerLabels: true,\n  },\n  render: ({ ...args }) => {\n    return (\n      <div className='h-[300px] w-[200px]'>\n        <Slider {...args} />\n      </div>\n    );\n  },\n};\n\nexport const RangeWithMarkers: Story = {\n  args: {\n    defaultValue: [25, 75],\n    label: 'Price Range',\n    markers: [0, 25, 50, 75, 100],\n  },\n  render: ({ ...args }) => {\n    return (\n      <div className='size-[400px]'>\n        <Slider {...args} />\n      </div>\n    );\n  },\n};\n\nexport const DisabledWithMarkers: Story = {\n  args: {\n    defaultValue: 50,\n    label: 'Disabled Slider',\n    isDisabled: true,\n    markers: 5,\n  },\n  render: ({ ...args }) => {\n    return (\n      <div className='size-[400px]'>\n        <Slider {...args} />\n      </div>\n    );\n  },\n};\n\nexport const SnapToMarkers: Story = {\n  args: {\n    defaultValue: 50,\n    label: 'Discrete Selection',\n    markers: [0, 25, 50, 75, 100],\n    snapToMarkers: true,\n  },\n  render: ({ ...args }) => {\n    return (\n      <div className='size-[400px]'>\n        <Slider {...args} />\n      </div>\n    );\n  },\n};\n\nexport const SnapToLabeledMarkers: Story = {\n  args: {\n    defaultValue: 50,\n    label: 'Rating',\n    markers: [\n      { value: 0, label: 'Poor' },\n      { value: 25, label: 'Fair' },\n      { value: 50, label: 'Good' },\n      { value: 75, label: 'Great' },\n      { value: 100, label: 'Excellent' },\n    ],\n    snapToMarkers: true,\n    showMarkerLabels: true,\n  },\n  render: ({ ...args }) => {\n    return (\n      <div className='size-[400px]'>\n        <Slider {...args} />\n      </div>\n    );\n  },\n};\n\nexport const SnapToUnevenMarkers: Story = {\n  args: {\n    defaultValue: 0,\n    label: 'Zoom Level',\n    markers: [\n      { value: 0, label: '1x' },\n      { value: 10, label: '2x' },\n      { value: 25, label: '4x' },\n      { value: 50, label: '8x' },\n      { value: 100, label: '16x' },\n    ],\n    snapToMarkers: true,\n    showMarkerLabels: true,\n  },\n  render: ({ ...args }) => {\n    return (\n      <div className='size-[400px]'>\n        <Slider {...args} />\n      </div>\n    );\n  },\n};\n\nexport const RangeWithSnap: Story = {\n  args: {\n    defaultValue: [25, 75],\n    label: 'Price Range',\n    markers: [\n      { value: 0, label: '$0' },\n      { value: 25, label: '$25' },\n      { value: 50, label: '$50' },\n      { value: 75, label: '$75' },\n      { value: 100, label: '$100' },\n    ],\n    snapToMarkers: true,\n    showMarkerLabels: true,\n  },\n  render: ({ ...args }) => {\n    return (\n      <div className='size-[400px]'>\n        <Slider {...args} />\n      </div>\n    );\n  },\n};\n"
        }
      ],
      "edges": []
    },
    "meta": {
      "missing": [
        {
          "name": "Slider",
          "reason": "No contract found (third-party or not scanned)",
          "referencedBy": "components/slider/slider.stories.tsx"
        }
      ],
      "source": "logicstamp-context@0.3.2"
    }
  },
  {
    "$schema": "https://logicstamp.dev/schemas/context/v0.1.json",
    "position": "3/3",
    "type": "LogicStampBundle",
    "schemaVersion": "0.1",
    "entryId": "components/slider/types.ts",
    "depth": 2,
    "createdAt": "2025-12-22T18:06:43.845Z",
    "bundleHash": "uifb:02eaafa018e505325575fd92",
    "graph": {
      "nodes": [
        {
          "entryId": "components/slider/types.ts",
          "contract": {
            "type": "UIFContract",
            "schemaVersion": "0.3",
            "kind": "ts:module",
            "entryId": "components/slider/types.ts",
            "description": "types - Type definitions",
            "version": {
              "variables": [],
              "hooks": [],
              "components": [],
              "functions": [],
              "imports": ["react-aria-components"]
            },
            "logicSignature": {
              "props": {
                "classNames": {
                  "type": "{ slider?: AriaSliderProps; label?: LabelProps; inputs?: string; input?: string; track?: SliderTrackProps; trackBackground?: string; trackValue?: string; thumb?: SliderThumbProps; minValue?: string; maxValue?: string; markers?: string; marker?: string; markerDot?: string; markerLabel?: string; }",
                  "optional": true
                },
                "label": "string",
                "layout": {
                  "type": "literal-union",
                  "literals": ["grid", "stack"],
                  "optional": true
                },
                "markers": {
                  "type": "import(\"/Users/brandonpierce/Projects/standard-toolkit/packages/design-toolkit/src/components/slider/types\").SliderMarkersConfig",
                  "optional": true
                },
                "showInput": {
                  "type": "boolean",
                  "optional": true
                },
                "showLabel": {
                  "type": "boolean",
                  "optional": true
                },
                "showMarkerLabels": {
                  "type": "boolean",
                  "optional": true
                },
                "showValueLabels": {
                  "type": "boolean",
                  "optional": true
                },
                "snapToMarkers": {
                  "type": "boolean",
                  "optional": true
                }
              },
              "emits": {}
            },
            "semanticHash": "uif:bec1e0d17eeb8a329ccdb05a",
            "fileHash": "uif:4dc083d9ec29cc420e214ce8"
          },
          "codeHeader": null,
          "code": "/*\n * Copyright 2025 Hypergiant Galactic Systems Inc. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport type {\n  SliderProps as AriaSliderProps,\n  LabelProps,\n  SliderThumbProps,\n  SliderTrackProps,\n} from 'react-aria-components';\n\nexport type SliderMarker = {\n  value: number;\n  label?: string;\n};\n\nexport type SliderMarkersConfig =\n  | number // Number of evenly spaced markers (includes min/max)\n  | SliderMarker[] // Explicit marker positions with optional labels\n  | number[]; // Array of values without labels\n\nexport type SliderProps = Omit<AriaSliderProps, 'children' | 'className'> & {\n  classNames?: {\n    slider?: AriaSliderProps['className'];\n    label?: LabelProps['className'];\n    inputs?: string;\n    input?: string;\n    track?: SliderTrackProps['className'];\n    trackBackground?: string;\n    trackValue?: string;\n    thumb?: SliderThumbProps['className'];\n    minValue?: string;\n    maxValue?: string;\n    markers?: string;\n    marker?: string;\n    markerDot?: string;\n    markerLabel?: string;\n  };\n  label: string;\n  layout?: 'grid' | 'stack';\n  /**\n   * Configure discrete marker points on the slider track.\n   * - number: Creates evenly spaced markers (e.g., 5 creates markers at 0%, 25%, 50%, 75%, 100%)\n   * - number[]: Array of specific values to mark\n   * - SliderMarker[]: Array of objects with value and optional label\n   */\n  markers?: SliderMarkersConfig;\n  /**\n   * Whether to display numeric input fields for direct value entry\n   */\n  showInput?: boolean;\n  showLabel?: boolean;\n  /**\n   * Whether to show labels on markers (only applies when markers have labels)\n   */\n  showMarkerLabels?: boolean;\n  /**\n   * Whether to show the min/max value labels (default: true)\n   */\n  showValueLabels?: boolean;\n  /**\n   * When true, the slider can only be set to marker values.\n   * Requires markers to be defined. The slider will snap to the nearest marker.\n   */\n  snapToMarkers?: boolean;\n};\n"
        }
      ],
      "edges": []
    },
    "meta": {
      "missing": [],
      "source": "logicstamp-context@0.3.2"
    }
  }
]
