import { Meta } from '@storybook/addon-docs/blocks';

import * as CameraStories from './camera.stories';

<Meta of={CameraStories} />

# Camera

A framework-agnostic state management system for camera control in web mapping applications. The Camera module provides a reactive, event-driven API for managing map camera state including position, zoom, rotation, pitch, and projection modes.

## Features

- **Event-Driven Architecture**: Uses a broadcast event bus for decoupled camera control
- **Multiple View Modes**: Support for 2D, 2.5D, and 3D camera views
- **Projection Types**: Switch between Mercator and Globe projections
- **Concurrent-Safe**: Built on `useSyncExternalStore` for React 18+ concurrent features
- **Automatic Cleanup**: Manages subscriptions and state lifecycle automatically
- **Type-Safe Events**: Full TypeScript support with discriminated union types
- **Framework Agnostic**: Core logic works independently of React
- **Fan-Out Pattern**: Single bus listener per camera instance, supporting N # of React subscribers

## Dependencies

Map Mode requires the following dependencies:

**Required:**
- [`@accelint/bus`](https://github.com/gohypergiant/standard-toolkit/tree/main/packages/bus) - Event bus for decoupled communication between mode consumers
- [`@accelint/core`](https://github.com/gohypergiant/standard-toolkit/tree/main/packages/core) - Core utilities including unique ID generation

**React Integration:**
- `react` - React 19.0.0 or higher for the `useMapCamera` hook

**Installation:**

```bash
npm install @accelint/map-toolkit @accelint/bus @accelint/core react
# or
pnpm add @accelint/map-toolkit @accelint/bus @accelint/core react
```

## Basic Usage

### Hook Usage

```tsx
import { useMapCamera } from '@accelint/map-toolkit/camera';
import { uuid } from '@accelint/core';

const MAP_ID = uuid();

function CameraInfo() {
  const { cameraState } = useMapCamera(MAP_ID);

  return (
    <div className="bg-white p-2 rounded shadow">
      <div>Lat: {cameraState.latitude.toFixed(2)}</div>
      <div>Lon: {cameraState.longitude.toFixed(2)}</div>
      <div>Zoom: {cameraState.zoom.toFixed(1)}</div>
      <div>Pitch: {cameraState.pitch}°</div>
      <div>Rotation: {cameraState.rotation}°</div>
      <div>View: {cameraState.view}</div>
      <div>Projection: {cameraState.projection}</div>
    </div>
  );
}
```

### Controlling the Camera

```tsx
import { Broadcast } from '@accelint/bus';
import { CameraEventTypes } from '@accelint/map-toolkit/camera';
import type { CameraEvent } from '@accelint/map-toolkit/camera';

const bus = Broadcast.getInstance<CameraEvent>();

function CameraControls({ instanceId }: { instanceId: UniqueId }) {
  const handleSetCenter = () => {
    bus.emit(CameraEventTypes.setCenter, {
      id: instanceId,
      latitude: 37.7749,
      longitude: -122.4194,
      zoom: 10,
    });
  };

  const handleFitBounds = () => {
    bus.emit(CameraEventTypes.fitBounds, {
      id: instanceId,
      bounds: [-122.5, 37.7, -122.3, 37.8], // [minLon, minLat, maxLon, maxLat]
      width: 800,
      height: 600,
      padding: 20,
    });
  };

  const handleSetView = (view: '2D' | '2.5D' | '3D') => {
    bus.emit(CameraEventTypes.setView, {
      id: instanceId,
      view,
    });
  };

  return (
    <div>
      <button onClick={handleSetCenter}>Go to San Francisco</button>
      <button onClick={handleFitBounds}>Fit Bay Area</button>
      <button onClick={() => handleSetView('2D')}>2D View</button>
      <button onClick={() => handleSetView('2.5D')}>2.5D View</button>
      <button onClick={() => handleSetView('3D')}>3D View</button>
    </div>
  );
}
```

## Camera State

### CameraState Type

The camera state is a discriminated union based on the view type:

**2D State**
```typescript
{
  latitude: number;
  longitude: number;
  zoom: number;
  pitch: 0;              // Always 0 in 2D
  rotation: number;      // 0-360 degrees
  projection: 'mercator';
  view: '2D';
}
```

**2.5D State**
```typescript
{
  latitude: number;
  longitude: number;
  zoom: number;
  pitch: number;         // 0-85 degrees
  rotation: number;      // 0-360 degrees
  projection: 'mercator';
  view: '2.5D';
}
```

**3D State**
```typescript
{
  latitude: number;
  longitude: number;
  zoom: number;
  pitch: number;         // Always 0 in 3D
  rotation: number;           // 0-360 degrees
  projection: 'globe';
  view: '3D';
}
```

### Initial Camera State

You can provide an initial camera state when using the hook:

```tsx
const { cameraState } = useMapCamera(MAP_ID, {
  latitude: 38.9072,
  longitude: -77.0369,
  zoom: 10,
  pitch: 45,
  rotation: 0,
  projection: 'mercator',
  view: '2.5D',
});
```

## Camera Events

### setCenter

Move the camera to a specific location with optional zoom, heading, and pitch.

```tsx
bus.emit(CameraEventTypes.setCenter, {
  id: instanceId,
  latitude: 40.7128,
  longitude: -74.0060,
  zoom: 12,           // optional
  heading: 45,        // optional rotation in degrees
  pitch: 30,          // optional pitch in degrees
});
```

### fitBounds

Fit the camera to show a specific bounding box.

```tsx
bus.emit(CameraEventTypes.fitBounds, {
  id: instanceId,
  bounds: [-122.5, 37.7, -122.3, 37.8], // [minLon, minLat, maxLon, maxLat]
  width: 800,         // viewport width in pixels
  height: 600,        // viewport height in pixels
  padding: 50,        // optional padding in pixels
  heading: 0,         // optional rotation
  pitch: 0,           // optional pitch
});
```

### setView

Change the camera view mode (2D, 2.5D, or 3D). This automatically adjusts projection and pitch/rotation constraints.

```tsx
// Switch to 2.5D view (sets pitch to 45°)
bus.emit(CameraEventTypes.setView, {
  id: instanceId,
  view: '2.5D',
});

// Switch to 3D view (changes to globe projection, resets rotation)
bus.emit(CameraEventTypes.setView, {
  id: instanceId,
  view: '3D',
});

// Switch to 2D view (resets pitch to 0°)
bus.emit(CameraEventTypes.setView, {
  id: instanceId,
  view: '2D',
});
```

### setProjection

Change the map projection type.

```tsx
// Switch to globe projection (automatically sets view to 3D)
bus.emit(CameraEventTypes.setProjection, {
  id: instanceId,
  projection: 'globe',
});

// Switch to Mercator projection (automatically sets view to 2D)
bus.emit(CameraEventTypes.setProjection, {
  id: instanceId,
  projection: 'mercator',
});
```

### setZoom

Change the zoom level.

```tsx
bus.emit(CameraEventTypes.setZoom, {
  id: instanceId,
  zoom: 14,
});
```

### setRotation

Set the rotation angle (bearing/heading). Only works in 2D and 2.5D modes.

```tsx
bus.emit(CameraEventTypes.setRotation, {
  id: instanceId,
  rotation: 90, // 0-360 degrees
});
```

### setPitch

Set the pitch (tilt) angle. Only works with Mercator projection (2D/2.5D modes).

```tsx
bus.emit(CameraEventTypes.setPitch, {
  id: instanceId,
  pitch: 45, // 0-65 degrees
});
```

### reset

Reset the camera to initial state, with optional preservation of zoom, pitch, or rotation.

```tsx
// Full reset
bus.emit(CameraEventTypes.reset, {
  id: instanceId,
});

// Reset but keep current zoom
bus.emit(CameraEventTypes.reset, {
  id: instanceId,
  zoom: false,
});

// Reset but keep pitch and rotation
bus.emit(CameraEventTypes.reset, {
  id: instanceId,
  pitch: false,
  rotation: false,
});
```

## Hook API

### useMapCamera

```tsx
function useMapCamera(
  mapId: UniqueId,
  initialCameraState?: CameraStateInput
): {
  cameraState: CameraState;
  setCameraState: (state: Partial<CameraState>) => void;
}
```

#### Parameters

##### `mapId: UniqueId` (required)

The unique identifier for the camera instance. Must match the `id` prop passed to your map component.

##### `initialCameraState?: CameraStateInput`

Optional initial camera state. Only used on first call for this mapId. If not provided, defaults to:
```typescript
{
  latitude: 0,
  longitude: 0,
  zoom: 0,
  pitch: 0,
  rotation: 0,
  projection: 'mercator',
  view: '2D',
}
```

#### Return Value

```typescript
{
  cameraState: CameraState;
  setCameraState: (state: Partial<CameraState>) => void;
}
```

- `cameraState`: Current camera state object
- `setCameraState`: Function to manually update camera state (advanced use case)

## View Modes

### 2D View

Traditional flat map view with rotation enabled.

- **Projection**: Mercator
- **Pitch**: Fixed at 0°
- **Rotation**: 0-360°
- **Use Cases**: Standard mapping, route planning, overview maps

### 2.5D View

Tilted perspective view for depth perception.

- **Projection**: Mercator
- **Pitch**: 0-65° (defaults to 45°)
- **Rotation**: 0-360°
- **Use Cases**: Urban planning, terrain visualization, building visualization

### 3D View

Globe view for world-scale visualization.

- **Projection**: Globe
- **Pitch**: Fixed at 0°
- **Rotation**: Fixed at 0°
- **Use Cases**: Global data visualization, satellite imagery, flight paths

## Multiple Camera Instances

You can manage multiple independent cameras by using different instance IDs:

```tsx
const MAP_1_ID = uuid();
const MAP_2_ID = uuid();

function MultiMapView() {
  const { cameraState: camera1 } = useMapCamera(MAP_1_ID);
  const { cameraState: camera2 } = useMapCamera(MAP_2_ID);

  return (
    <div className="grid grid-cols-2">
      <BaseMap id={MAP_1_ID} />
      <BaseMap id={MAP_2_ID} />
    </div>
  );
}
```

## Advanced Usage

### Manual State Updates

While the event bus is the recommended approach, you can manually update camera state:

```tsx
const { cameraState, setCameraState } = useMapCamera(MAP_ID);

const handleClick = () => {
  setCameraState({
    latitude: 51.5074,
    longitude: -0.1278,
    zoom: 10,
  });
};
```

## Performance

### Fan-Out Pattern

The camera system uses an efficient fan-out pattern:

1. **Single Bus Listener**: One event bus listener per camera instance
2. **Multiple Subscribers**: N React components can subscribe to the same camera
3. **Automatic Cleanup**: When all subscribers unmount, the bus listener is removed

This prevents creating duplicate listeners and ensures efficient memory usage.

### Referential Stability

The hook maintains referential stability for snapshot functions and subscriptions using internal caching. This prevents unnecessary re-renders when the underlying state hasn't changed.

## Edge Cases

### Before Initialization

Before the first camera event or if no initial state is provided:

```tsx
const { cameraState } = useMapCamera(MAP_ID);

// Default values before initialization
console.log(cameraState);
// {
//   latitude: 0,
//   longitude: 0,
//   zoom: 0,
//   pitch: 0,
//   rotation: 0,
//   projection: 'mercator',
//   view: '2D'
// }
```

### View/Projection Constraints

When changing views or projections, certain properties are automatically adjusted:

- **2D → 2.5D**: Pitch set to 45°
- **2D → 3D**: Projection changed to 'globe', rotation reset to 0°
- **3D → 2D**: Projection changed to 'mercator', pitch reset to 0°
- **Setting Globe Projection**: View automatically set to '3D'
- **Setting Mercator Projection**: View automatically set to '2D', pitch reset to 0°

### Pitch Constraints

Pitch can only be set when using Mercator projection. Attempting to set pitch in globe projection mode will be ignored:

```tsx
// This works (2.5D view with Mercator projection)
bus.emit(CameraEventTypes.setPitch, {
  id: instanceId,
  pitch: 45,
});

// This is ignored (3D view with Globe projection)
// Globe projection doesn't support custom pitch
```

## Utilities

### clearCameraState

Manually clear camera state for an instance (rarely needed):

```tsx
import { clearCameraState } from '@accelint/map-toolkit/camera';

clearCameraState(MAP_ID);
```

**Note:** Automatic cleanup happens when all subscribers unmount.

## TypeScript Types

```typescript
import type {
  CameraState,
  CameraEvent,
  ProjectionType,
  ViewType,
  UseCameraStateProps,
  CameraSetCenterPayload,
  CameraFitBoundsPayload,
  CameraResetPayload,
} from '@accelint/map-toolkit/camera';
```

## Troubleshooting

### Camera not updating

**Causes:**
1. Wrong `mapId` (doesn't match map instance)
2. Event emitted before camera state initialized

**Solutions:**
1. Verify `mapId` matches across components
2. Ensure camera state is initialized before emitting events

### Pitch/Rotation not working

**Cause:** View/projection constraints preventing the change.

**Solution:** Check the current view mode:
- Pitch only works with Mercator projection (2D/2.5D)
- Rotation only works in 2D/2.5D modes (not 3D/globe)

### Multiple subscribers causing issues

**Cause:** Unexpected re-renders or stale state.

**Solution:** The hook handles subscription management automatically with proper caching and memoization.

## Related

- Viewport - Track viewport state and bounds
- BaseMap - Base map component
- @accelint/bus - Event bus system

## Examples

### Camera Toolbar

A complete example of a camera control toolbar:

```tsx
import { Broadcast } from '@accelint/bus';
import { useMapCamera, CameraEventTypes } from '@accelint/map-toolkit/camera';
import type { CameraEvent } from '@accelint/map-toolkit/camera';

function CameraToolbar({ mapId }: { mapId: UniqueId }) {
  const bus = Broadcast.getInstance<CameraEvent>();
  const { cameraState } = useMapCamera(mapId);

  return (
    <div className="camera-toolbar">
      <button onClick={() => bus.emit(CameraEventTypes.reset, { id: mapId })}>
        Reset
      </button>

      <input
        type="range"
        min={0}
        max={22}
        value={cameraState.zoom}
        onChange={(e) =>
          bus.emit(CameraEventTypes.setZoom, {
            id: mapId,
            zoom: Number(e.target.value),
          })
        }
      />

      <select
        value={cameraState.view}
        onChange={(e) =>
          bus.emit(CameraEventTypes.setView, {
            id: mapId,
            view: e.target.value as ViewType,
          })
        }
      >
        <option value="2D">2D</option>
        <option value="2.5D">2.5D</option>
        <option value="3D">3D</option>
      </select>
    </div>
  );
}
```

### Synchronized Cameras

Keep multiple cameras in sync:

```tsx
import { useEffect } from 'react';
import { Broadcast } from '@accelint/bus';
import { useMapCamera, CameraEventTypes } from '@accelint/map-toolkit/camera';

function SyncedMaps() {
  const PRIMARY_ID = uuid();
  const SECONDARY_ID = uuid();
  const bus = Broadcast.getInstance<CameraEvent>();

  const { cameraState: primaryState } = useMapCamera(PRIMARY_ID);

  // Sync secondary camera to primary
  useEffect(() => {
    bus.emit(CameraEventTypes.setCenter, {
      id: SECONDARY_ID,
      latitude: primaryState.latitude,
      longitude: primaryState.longitude,
      zoom: primaryState.zoom,
    });
  }, [primaryState.latitude, primaryState.longitude, primaryState.zoom]);

  return (
    <div className="grid grid-cols-2">
      <BaseMap id={PRIMARY_ID} />
      <BaseMap id={SECONDARY_ID} />
    </div>
  );
}
```

### Animated Camera Transitions

Create smooth camera transitions with animation libraries:

```tsx
import { useSpring, animated } from 'react-spring';
import { Broadcast } from '@accelint/bus';
import { CameraEventTypes } from '@accelint/map-toolkit/camera';

function AnimatedCamera({ mapId }: { mapId: UniqueId }) {
  const bus = Broadcast.getInstance<CameraEvent>();

  const animatedPosition = useSpring({
    from: { lat: 0, lng: 0, zoom: 2 },
    to: { lat: 37.7749, lng: -122.4194, zoom: 12 },
    config: { duration: 2000 },
  });

  useEffect(() => {
    const unsubscribe = animatedPosition.lat.onChange((value) => {
      bus.emit(CameraEventTypes.setCenter, {
        id: mapId,
        latitude: value,
        longitude: animatedPosition.lng.get(),
        zoom: animatedPosition.zoom.get(),
      });
    });

    return unsubscribe;
  }, [animatedPosition, mapId]);

  return null;
}
```
