/*
 * Copyright 2025 Hypergiant Galactic Systems Inc. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

'use client';

import 'client-only';
import { useEmit, useOn } from '@accelint/bus/react';
import { type UniqueId, uuid } from '@accelint/core';
import {
  createContext,
  type ReactNode,
  useCallback,
  useMemo,
  useRef,
  useState,
} from 'react';
import { MapModeEvents } from './events';
import type {
  ModeChangeAuthorizationEvent,
  ModeChangeDecisionEvent,
  ModeChangedEvent,
  ModeChangeRequestEvent,
} from './types';

/**
 * Internal type for tracking pending authorization requests.
 * Stored in a Map keyed by requester ID (requestOwner).
 * @internal
 */
type PendingRequest = {
  /** Unique identifier for this authorization request */
  authId: string;
  /** The mode being requested */
  desiredMode: string;
  /** The mode that was active when the request was made */
  currentMode: string;
  /** ID of the component/feature requesting the mode change */
  requestOwner: string;
};

/**
 * Context value provided by MapModeProvider to consumers.
 */
export type MapModeContextValue = {
  /** The current active map mode */
  mode: string;
  /** Function to request a mode change with ownership */
  requestModeChange: (desiredMode: string, requestOwner: string) => void;
};

/**
 * React context for map mode state.
 * Use the `useMapMode` hook to access this context.
 */
export const MapModeContext = createContext<MapModeContextValue | null>(null);

/**
 * Props for the MapModeProvider component.
 */
export type MapModeProviderProps = {
  /** Child components that will have access to map mode context */
  children: ReactNode;
  /** The default mode to start with. Defaults to 'default' */
  defaultMode?: string;
  /** The map instance id of the deckgl map the provider wraps.
   * Autogenerated if not user-provided */
  mapId?: UniqueId;
};

const DEFAULT_MODE = 'default';

/**
 * Provider component for managing map modes with ownership and authorization.
 *
 * This component manages a state machine for map modes where components can request
 * mode changes with ownership. When a mode is owned by a component, other components
 * must request authorization to change to a different mode. The provider handles:
 *
 * - Automatic mode changes when no ownership conflicts exist
 * - Authorization flow when switching between owned modes
 * - Per-mode ownership tracking that persists throughout the session
 * - Pending request management (one pending request per requester)
 * - Auto-acceptance of first pending request when mode owner returns to default
 * - Auto-rejection of other pending requests when one is approved
 * - Event emission through a centralized event bus
 *
 * ## Pending Request Behavior
 *
 * - Pending requests are stored by requester ID (not mode owner)
 * - Each requester can have only one pending request at a time
 * - New requests from the same requester auto-replace previous requests
 * - Pending requests persist when mode owner switches between their own modes
 * - When any request is approved, all other pending requests are auto-rejected
 * - When mode owner returns to default mode:
 *   - If first pending request is for default mode, all pending requests are rejected (already in requested mode)
 *   - If first pending request is for a different mode, that request is auto-approved and others are rejected
 *
 * @param props - Provider props including children and optional defaultMode
 * @returns Provider component that wraps children with map mode context
 *
 * @example
 * Basic usage:
 * ```tsx
 * import { MapModeProvider } from '@accelint/map-toolkit/deckgl';
 *
 * function App() {
 *   return (
 *     <MapModeProvider defaultMode="view">
 *       <MapView />
 *     </MapModeProvider>
 *   );
 * }
 * ```
 *
 * @example
 * With authorization handling:
 * ```tsx
 * import { MapModeProvider, useMapMode } from '@accelint/map-toolkit/deckgl';
 * import { useOn, useEmit } from '@accelint/bus/react';
 * import { MapModeEvents } from '@accelint/map-toolkit/deckgl';
 *
 * function DrawingTool() {
 *   const { requestModeChange } = useMapMode();
 *   const emitDecision = useEmit(MapModeEvents.changeDecision);
 *
 *   // Listen for authorization requests
 *   useOn(MapModeEvents.changeAuthorization, (event) => {
 *     const { authId, desiredMode } = event.payload;
 *     // Approve or reject the request
 *     emitDecision({ authId, approved: true, owner: 'drawing-tool' });
 *   });
 *
 *   return (
 *     <button onClick={() => requestModeChange('drawing', 'drawing-tool')}>
 *       Start Drawing
 *     </button>
 *   );
 * }
 * ```
 */
export function MapModeProvider({
  children,
  defaultMode = DEFAULT_MODE,
  mapId,
}: MapModeProviderProps) {
  const [mode, setMode] = useState(defaultMode);
  // Generate stable instance ID (only once per provider mount)
  const autoId = useMemo(() => uuid(), []);
  const mapInstanceId: UniqueId = mapId ?? autoId;
  // Store mode-to-owner mappings (persists throughout session, no re-renders needed)
  const modeOwnersRef = useRef<Map<string, string>>(new Map());
  // Store pending authorization requests by requester (one request per requester, no re-renders needed)
  const pendingRequestsRef = useRef<Map<string, PendingRequest>>(new Map());

  const emitChanged = useEmit<ModeChangedEvent>(MapModeEvents.changed);
  const emitAuthorization = useEmit<ModeChangeAuthorizationEvent>(
    MapModeEvents.changeAuthorization,
  );
  const emitRequest = useEmit<ModeChangeRequestEvent>(
    MapModeEvents.changeRequest,
  );
  const emitDecision = useEmit<ModeChangeDecisionEvent>(
    MapModeEvents.changeDecision,
  );

  // Helper to approve a request and reject all others
  const approveRequestAndRejectOthers = useCallback(
    (
      approvedRequest: PendingRequest,
      excludeAuthId: string,
      decisionOwner: string,
      reason: string,
      emitApproval: boolean,
    ) => {
      const previousMode = mode;

      // Collect all other pending requests to emit rejections for
      const requestsToReject: PendingRequest[] = [];
      for (const [, request] of pendingRequestsRef.current.entries()) {
        if (request.authId !== excludeAuthId) {
          requestsToReject.push(request);
        }
      }

      // Clear all pending requests BEFORE changing mode and emitting events
      // This prevents the mode changed listener from seeing stale pending requests
      pendingRequestsRef.current.clear();

      // Change mode to the requested mode
      setMode(approvedRequest.desiredMode);
      emitChanged({
        previousMode,
        currentMode: approvedRequest.desiredMode,
        mapInstanceId,
      });

      // Store the new mode's owner
      modeOwnersRef.current.set(
        approvedRequest.desiredMode,
        approvedRequest.requestOwner,
      );

      // Emit approval decision (only if requested, e.g., for auto-accepts)
      if (emitApproval) {
        emitDecision({
          authId: approvedRequest.authId,
          approved: true,
          owner: decisionOwner,
          reason,
          mapInstanceId,
        });
      }

      // Emit rejection events for all other pending requests
      for (const request of requestsToReject) {
        emitDecision({
          authId: request.authId,
          approved: false,
          owner: decisionOwner,
          reason: 'Request auto-rejected because another request was approved',
          mapInstanceId,
        });
      }
    },
    [mode, emitChanged, emitDecision, mapInstanceId],
  );

  // Centralized listener for mode change requests
  useOn<ModeChangeRequestEvent>(
    MapModeEvents.changeRequest,
    (event: ModeChangeRequestEvent) => {
      const {
        desiredMode,
        owner: requestOwner,
        mapInstanceId: eventMapInstanceId,
      } = event.payload;
      // Filter: only handle if targeted at this instance
      if (eventMapInstanceId !== mapInstanceId || desiredMode === mode) {
        return;
      }

      // Get current mode's owner from the mapping
      const currentModeOwner = modeOwnersRef.current.get(mode);
      // Get desired mode's owner from the mapping
      const desiredModeOwner = modeOwnersRef.current.get(desiredMode);

      // Auto-accept if:
      // 1. Desired mode is 'default' AND requesting owner is the current mode owner
      // 2. Requesting owner is same as current mode owner, OR
      // 3. No current or desired mode owner, OR
      // 4. In default mode and the requester is the owner of the desired mode
      if (
        (desiredMode === defaultMode && requestOwner === currentModeOwner) ||
        requestOwner === currentModeOwner ||
        !(currentModeOwner || desiredModeOwner) ||
        (mode === defaultMode && requestOwner === desiredModeOwner)
      ) {
        setMode(desiredMode);
        emitChanged({
          previousMode: mode,
          currentMode: desiredMode,
          mapInstanceId,
        });

        // Store the desired mode's owner unless it's default (which stays ownerless),
        // and there's not another mode owner already
        if (desiredMode !== defaultMode && !desiredModeOwner) {
          modeOwnersRef.current.set(desiredMode, requestOwner);
        }

        // Clear requester's pending request since mode changed successfully
        // Note: Only clear the requester's own pending request, not all pending requests
        // This preserves pending requests when mode owner changes between their own modes
        pendingRequestsRef.current.delete(requestOwner);
        return;
      }

      // Otherwise, send authorization request
      // Generate authId and store the request keyed by requester
      // (auto-replaces any previous pending request from this requester)
      const authId = uuid();

      pendingRequestsRef.current.set(requestOwner, {
        authId,
        desiredMode,
        currentMode: mode,
        requestOwner,
      });

      emitAuthorization({
        authId,
        desiredMode,
        currentMode: mode,
        mapInstanceId,
      });
    },
  );

  // Centralized listener for authorization decisions
  useOn<ModeChangeDecisionEvent>(MapModeEvents.changeDecision, (event) => {
    const {
      approved,
      authId,
      owner: decisionOwner,
      mapInstanceId: eventMapInstanceId,
    } = event.payload;

    // Filter: only handle if targeted at this instance
    if (eventMapInstanceId !== mapInstanceId) {
      return;
    }

    // Verify decision is from current mode's owner
    const currentModeOwner = modeOwnersRef.current.get(mode);
    if (decisionOwner !== currentModeOwner) {
      // Unauthorized decision, ignore (noop)
      return;
    }

    // Find the request with matching authId
    let matchingRequestOwner: string | null = null;
    let matchingRequest: PendingRequest | null = null;

    for (const [
      requestOwner,
      request,
    ] of pendingRequestsRef.current.entries()) {
      if (request.authId === authId) {
        matchingRequestOwner = requestOwner;
        matchingRequest = request;
        break;
      }
    }

    if (!(matchingRequest && matchingRequestOwner)) {
      // Unknown or stale authId, ignore
      return;
    }

    if (approved) {
      approveRequestAndRejectOthers(
        matchingRequest,
        authId,
        decisionOwner,
        '',
        false, // Don't emit approval - it was already emitted by the caller
      );
    } else {
      // Just remove the rejected request, don't auto-reject others
      pendingRequestsRef.current.delete(matchingRequestOwner);
    }
  });

  // Helper to handle pending requests when returning to default mode
  const handlePendingRequestsOnDefaultMode = useCallback(
    (previousMode: string) => {
      const firstEntry = Array.from(pendingRequestsRef.current.entries())[0];
      if (!firstEntry) {
        return;
      }

      const [, firstRequest] = firstEntry;
      const previousModeOwner = modeOwnersRef.current.get(previousMode);

      // Only process if returning to default from an owned mode
      if (!previousModeOwner) {
        return;
      }

      // If the first pending request is for the mode we're already in (default),
      // reject it instead of trying to approve it (which would create an infinite loop)
      if (firstRequest.desiredMode === defaultMode) {
        // Collect all pending requests (including the default one) to reject
        const allRequests: PendingRequest[] = Array.from(
          pendingRequestsRef.current.values(),
        );

        // Clear all pending requests BEFORE emitting events
        pendingRequestsRef.current.clear();

        // Reject all pending requests since we're already in the desired mode
        for (const request of allRequests) {
          emitDecision({
            authId: request.authId,
            approved: false,
            owner: previousModeOwner,
            reason: 'Request rejected - already in requested mode',
            mapInstanceId,
          });
        }
      } else {
        // Auto-accept the first pending request for a different mode
        approveRequestAndRejectOthers(
          firstRequest,
          firstRequest.authId,
          previousModeOwner,
          'Auto-accepted when mode owner returned to default',
          true, // Emit approval decision for auto-accept
        );
      }
    },
    [defaultMode, approveRequestAndRejectOthers, emitDecision, mapInstanceId],
  );

  // Listen for mode changes to auto-accept first pending request when returning to default
  useOn<ModeChangedEvent>(MapModeEvents.changed, (event) => {
    const {
      currentMode,
      previousMode,
      mapInstanceId: eventMapInstanceId,
    } = event.payload;
    // Filter: only handle if targeted at this instance
    if (eventMapInstanceId !== mapInstanceId) {
      return;
    }

    // When mode owner changes to default mode, handle pending requests
    if (currentMode === defaultMode && pendingRequestsRef.current.size > 0) {
      handlePendingRequestsOnDefaultMode(previousMode);
    }
  });

  const requestModeChange = useCallback(
    (desiredMode: string, requestOwner: string) => {
      // Validate inputs
      if (!desiredMode) {
        throw new Error('requestModeChange requires non-empty desiredMode');
      }
      if (!requestOwner) {
        throw new Error('requestModeChange requires non-empty requestOwner');
      }

      emitRequest({
        desiredMode,
        owner: requestOwner,
        mapInstanceId,
      });
    },
    [emitRequest, mapInstanceId],
  );

  const value = useMemo(
    () => ({
      mode,
      requestModeChange,
    }),
    [mode, requestModeChange],
  );

  return (
    <MapModeContext.Provider value={value}>{children}</MapModeContext.Provider>
  );
}
