import { Meta } from '@storybook/addon-docs/blocks';

import * as DisplayShapeLayerStories from './display-shape-layer.stories';

<Meta of={DisplayShapeLayerStories} />

# Display Shape Layer

A read-only deck.gl composite layer for displaying geographic shapes with interactive features, labels, and customizable styling. Ideal for rendering shapes from external APIs or displaying geographic data without editing capabilities.

## Features

- **Multiple geometry types**: Point, LineString, Polygon, and Circle
- **Icon support**: Custom icons for Point geometries via icon atlases
- **Interactive selection**: Click handling with visual highlight feedback
- **Hover effects**: Border/outline width increases on hover; Points with icons show coffin corners
- **Customizable labels**: White uppercase text with black outline, flexible positioning
- **Style properties**: Full control over colors, border/outline patterns, and opacity
- **Event bus integration**: Automatically emits shape events via @accelint/bus
- **Multi-map support**: Events include map instance ID for isolation
- **Cursor integration**: Works with map-cursor for hover cursor changes

## Dependencies

DisplayShapeLayer requires the following dependencies:

**Required:**
- [`@accelint/bus`](https://github.com/gohypergiant/standard-toolkit/tree/main/packages/bus) - Event bus for shape interaction events
- [`@accelint/core`](https://github.com/gohypergiant/standard-toolkit/tree/main/packages/core) - Core utilities including UUID generation
- [`@deck.gl/core`](https://deck.gl/) - Deck.gl core library for WebGL visualization
- [`@deck.gl/layers`](https://deck.gl/) - Deck.gl layer implementations (GeoJsonLayer, TextLayer)
- [`@deck.gl/extensions`](https://deck.gl/) - Deck.gl extensions (PathStyleExtension for dash patterns)
- [`@deckgl-fiber-renderer/dom`](https://github.com/deckgl-fiber-renderer/fiber.gl) - React renderer for Deck.gl (for fiber usage)
- [`geojson`](https://www.npmjs.com/package/geojson) - GeoJSON TypeScript types
- `react` - React 19.0.0 or higher

**Installation:**

```bash
npm install @accelint/map-toolkit @accelint/bus @accelint/core @deck.gl/core @deck.gl/layers @deck.gl/extensions @deckgl-fiber-renderer/dom geojson react
# or
pnpm add @accelint/map-toolkit @accelint/bus @accelint/core @deck.gl/core @deck.gl/layers @deck.gl/extensions @deckgl-fiber-renderer/dom geojson react
```

## Basic Usage

### With Fiber Renderer (Recommended)

The easiest way to use DisplayShapeLayer is with the `useShapeSelection` hook, which handles selection state and auto-deselection when clicking empty space:

```tsx
import { BaseMap } from '@accelint/map-toolkit/deckgl/base-map';
import '@accelint/map-toolkit/deckgl/shapes/display-shape-layer/fiber';
import { useShapeSelection } from '@accelint/map-toolkit/deckgl/shapes';
import { uuid } from '@accelint/core';

// Stable map ID for event isolation
const MAP_ID = uuid();

function MapWithShapes() {
  const { selectedId } = useShapeSelection(MAP_ID);
  const shapes = [
    {
      id: '1',
      name: 'My Location',
      shapeType: 'Point',
      locked: false,
      feature: {
        type: 'Feature',
        properties: {
          styleProperties: {
            fillColor: [98, 166, 255, 150], // RGBA: blue at ~60% opacity
            lineColor: [98, 166, 255, 255], // RGBA: blue at full opacity
            lineWidth: 4,
            linePattern: 'solid',
          },
        },
        geometry: {
          type: 'Point',
          coordinates: [-122.4, 37.8],
        },
      },
    },
  ];

  return (
    <BaseMap id={MAP_ID}>
      <displayShapeLayer
        id="my-shapes"
        mapId={MAP_ID}
        data={shapes}
        selectedShapeId={selectedId}
        showLabels={true}
        pickable={true}
      />
    </BaseMap>
  );
}
```

### Listening to Selection Events

While `useShapeSelection` manages selection state automatically, you can also listen to selection events for side effects like logging, analytics, or coordinating with other UI:

```tsx
import { BaseMap } from '@accelint/map-toolkit/deckgl/base-map';
import '@accelint/map-toolkit/deckgl/shapes/display-shape-layer/fiber';
import { useShapeSelection } from '@accelint/map-toolkit/deckgl/shapes';
import { useOn } from '@accelint/bus/react';
import { ShapeEvents } from '@accelint/map-toolkit/deckgl/shapes/shared/events';
import { uuid } from '@accelint/core';

const MAP_ID = uuid();

function MapWithShapes() {
  // useShapeSelection handles selection state and click-away deselection
  const { selectedId } = useShapeSelection(MAP_ID);

  // Listen to events for side effects (logging, analytics, etc.)
  useOn(ShapeEvents.selected, (event) => {
    if (event.payload.mapId !== MAP_ID) return;
    console.log('Shape selected:', event.payload.shapeId);
  });

  return (
    <BaseMap id={MAP_ID}>
      <displayShapeLayer
        id="my-shapes"
        mapId={MAP_ID}
        data={shapes}
        selectedShapeId={selectedId}
      />
    </BaseMap>
  );
}
```

> **Note**: Avoid using `useOn` with `useState` to manage selection state directly. The `useShapeSelection` hook uses a store pattern that ensures only one bus listener per map instance and proper cleanup. Using `useOn` directly can create N listeners for N components and may accumulate listeners during HMR.

### Direct Layer Usage (without BaseMap)

```tsx
import { Deck } from '@deck.gl/core';
import { DisplayShapeLayer } from '@accelint/map-toolkit/deckgl/shapes/display-shape-layer';
import { uuid } from '@accelint/core';

const MAP_ID = uuid();

const layer = new DisplayShapeLayer({
  id: 'shapes',
  mapId: MAP_ID,
  data: shapes,
  pickable: true,
  showLabels: true,
  onShapeClick: (shape) => {
    console.log('Clicked shape:', shape.name);
  },
});

new Deck({
  initialViewState: {
    longitude: -122.4,
    latitude: 37.8,
    zoom: 11,
  },
  controller: true,
  layers: [layer],
});
```

## Shape Data Structure

`Shape` is a discriminated union of specific shape types (`CircleShape`, `EllipseShape`, `PolygonShape`, `RectangleShape`, `LineStringShape`, `PointShape`). Each shape includes:

```typescript
interface BaseShape {
  /** Unique identifier (use uuid() from @accelint/core) */
  id: UniqueId;
  /** Full shape name used internally and in UI */
  name: string;
  /** Optional short display label shown on the map */
  label?: string;
  /** Shape type discriminator */
  shapeType: 'Point' | 'LineString' | 'Polygon' | 'Rectangle' | 'Circle' | 'Ellipse';
  /** GeoJSON feature with geometry and style properties */
  feature: StyledFeature;
  /** Whether shape is locked from editing */
  locked?: boolean;
  /** UTC timestamp (optional) */
  lastUpdated?: number;
}
```

### Type Guards

Use the provided type guards to narrow shape types and access type-specific properties:

```typescript
import {
  isCircleShape,
  isEllipseShape,
  isPolygonShape,
  isRectangleShape,
  isLineStringShape,
  isPointShape,
} from '@accelint/map-toolkit/deckgl/shapes';

function handleShape(shape: Shape) {
  if (isCircleShape(shape)) {
    // TypeScript knows shape is CircleShape
    // shape.feature.properties.circleProperties is available
    const { center, radius } = shape.feature.properties.circleProperties;
    console.log(`Circle at ${center} with radius ${radius.value} ${radius.units}`);
  }

  if (isEllipseShape(shape)) {
    // shape.feature.properties.ellipseProperties is available
    const { center, xSemiAxis, ySemiAxis, angle } = shape.feature.properties.ellipseProperties;
    console.log(`Ellipse at ${center}, rotated ${angle}Â°`);
  }
}
```

### Individual Shape Types

You can also import specific shape types for type annotations:

```typescript
import type {
  CircleShape,
  EllipseShape,
  PolygonShape,
  RectangleShape,
  LineStringShape,
  PointShape,
  Shape,
} from '@accelint/map-toolkit/deckgl/shapes';

function processCircle(circle: CircleShape) {
  // circle.feature.properties.circleProperties is guaranteed to exist
  const { center, radius } = circle.feature.properties.circleProperties;
}
```

### Circle and Ellipse Properties

Circles and ellipses store their defining parameters alongside the polygon approximation used for rendering:

```typescript
interface CircleProperties {
  /** Center point as [longitude, latitude] */
  center: [number, number];
  /** Radius with value and units */
  radius: {
    value: number;
    units: DistanceUnit; // 'meters' | 'kilometers' | 'miles' | 'nauticalmiles' | 'feet'
  };
}

interface EllipseProperties {
  /** Center point as [longitude, latitude] */
  center: [number, number];
  /** X semi-axis (horizontal radius) */
  xSemiAxis: { value: number; units: DistanceUnit };
  /** Y semi-axis (vertical radius) */
  ySemiAxis: { value: number; units: DistanceUnit };
  /** Rotation angle in degrees */
  angle: number;
}
```

### Style Properties

Control the visual appearance of each shape. Colors use deck.gl's `Color` type (RGBA arrays where each value is 0-255):

```typescript
import type { Color } from '@deck.gl/core';

interface StyleProperties {
  /** Fill color as RGBA array [r, g, b, a] where each value is 0-255 */
  fillColor: Color;
  /** Border/outline color as RGBA array [r, g, b, a] where each value is 0-255 */
  lineColor: Color;
  /** Border/outline width in pixels (1 | 2 | 4 | 8) */
  lineWidth: LineWidth;
  /** Border/outline pattern: 'solid' | 'dashed' | 'dotted' */
  linePattern: LinePattern;
  /** Optional icon properties for Point geometries */
  icon?: {
    atlas: string;
    mapping: Record<string, IconDefinition>;
    name: string;
    size?: number;
  };
  /** Optional custom label positioning */
  labelOffset?: [number, number];
  labelVerticalAnchor?: 'top' | 'middle' | 'bottom';
  labelHorizontalAnchor?: 'left' | 'center' | 'right';
  labelCoordinateAnchor?: 'center' | 'start' | 'middle' | 'end' | 'top' | 'right' | 'bottom' | 'left';
}
```

**Note**: By default, fill colors have a 20% opacity multiplier applied for the standard semi-transparent look. Set `applyBaseOpacity={false}` to render colors exactly as specified.

## Custom Icons for Points

Display custom icons for Point geometries using icon atlases:

```tsx
import ATLAS_PNG from './assets/atlas.png';
import ATLAS_JSON from './assets/atlas.json';

const pointWithIcon = {
  id: '1',
  name: 'Location Marker',
  shapeType: 'Point',
  locked: false,
  feature: {
    type: 'Feature',
    properties: {
      styleProperties: {
        fillColor: [98, 166, 255, 255], // RGBA
        lineColor: [98, 166, 255, 255], // RGBA
        lineWidth: 4,
        linePattern: 'solid',
        icon: {
          atlas: ATLAS_PNG,
          mapping: ATLAS_JSON,
          name: 'marker',
          size: 38,
        },
      },
    },
    geometry: {
      type: 'Point',
      coordinates: [-122.4, 37.8],
    },
  },
};
```

## Label Positioning

Labels are displayed as white uppercase text with a black outline for legibility across different map backgrounds.

The layer provides flexible label positioning with a three-tier priority system:

1. **Per-shape properties** in `styleProperties` (highest priority)
2. **Global `labelOptions`** prop
3. **Default values** (geometry-specific fallbacks)

### Global Label Options

Apply positioning to all shapes of a given type:

```tsx
<displayShapeLayer
  id="shapes"
  data={shapes}
  showLabels={true}
  labelOptions={{
    // Circle labels at the top of the perimeter
    circleLabelCoordinateAnchor: 'top',
    circleLabelVerticalAnchor: 'bottom',
    circleLabelOffset: [0, -10],

    // LineString labels at the center
    lineStringLabelCoordinateAnchor: 'center',
    lineStringLabelVerticalAnchor: 'top',
    lineStringLabelHorizontalAnchor: 'center',
    lineStringLabelOffset: [0, -15],

    // Point labels above with center alignment
    pointLabelVerticalAnchor: 'bottom',
    pointLabelHorizontalAnchor: 'center',
    pointLabelOffset: [0, -13],
  }}
/>
```

### Per-Shape Label Positioning

Override positioning for individual shapes via `styleProperties`:

```tsx
const shape = {
  // ... other properties
  feature: {
    properties: {
      styleProperties: {
        // ... style properties
        // Position this specific label at the center
        labelCoordinateAnchor: 'center',
        labelVerticalAnchor: 'bottom',
        labelHorizontalAnchor: 'right',
        labelOffset: [10, -20],
      },
    },
    // ...
  },
};
```

### Positioning Concepts

#### Coordinate Anchor

Determines *where* on the geometry to place the label:

- **Point**: Label is always at the point coordinate (no anchor needed)
- **LineString/Polygon**: `'center'` (centroid), or cardinal edges `'top'`, `'right'`, `'bottom'`, `'left'`
- **Circle**: `'center'` (center point), or perimeter positions `'top'`, `'right'`, `'bottom'`, `'left'`

#### Vertical/Horizontal Anchor

Determines how the label text aligns *relative to* the anchor point.

_Note: this is relative to the label text itself, and does not include offsets for not the bounding box around the text._

- **Vertical**
  - `'top'` - Label text appears below the point
  - `'middle'` - Label text is vertically centered
  - `'bottom'` - Label text appears above the point

- **Horizontal**
  - `'left'` - Label text appears to the right of the point
  - `'center'` - Label text is horizontally centered
  - `'right'` - Label text appears to the left of the point

#### Pixel Offset

Fine-tune label position with `[x, y]` pixel offsets:

- Positive x moves right, negative moves left
- Positive y moves down, negative moves up

### Default Label Positions

Each geometry type has sensible defaults (labels appear below shapes):

- **Point**: Below the point, centered horizontally, offset `[0, 10]`
- **LineString**: At bottom edge, top-aligned text, centered horizontally, offset `[0, 10]`
- **Polygon**: At bottom edge, top-aligned text, centered horizontally, offset `[0, 10]`
- **Circle**: At bottom of perimeter, top-aligned text, centered horizontally, offset `[0, 10]`

## Selection and Highlighting

### Visual Feedback

When a shape is selected via `selectedShapeId`, the layer provides visual indicators:

1. **Dotted border**: The selected shape's border/outline pattern changes to dotted (`[2, 4]` dash array)
2. **Coffin corners** (Point shapes with icons): Bracket-like corners appear around selected Point icons with a blue fill. These are not currently customizable.
3. **Highlight** (optional, non-icon-Point shapes): A highlight layer underneath with:
   - Increased border/outline width (+5 pixels)
   - Custom highlight color (default: turquoise at ~39% opacity)

### Controlling the Highlight Effect when Selecting Shapes

The highlight effect can be toggled with the `showHighlight` prop:

```tsx
// To show the highlight effect in addition to dotted border:
<displayShapeLayer
  id="shapes"
  data={shapes}
  selectedShapeId={selectedId}
  showHighlight={true}  // enables the highlight layer
/>

// Default behavior (no highlight, just dotted border):
<displayShapeLayer
  id="shapes"
  data={shapes}
  selectedShapeId={selectedId}
  // showHighlight={false} is the default - only dotted border shows on selection
/>
```

### Custom Highlight Color

```tsx
<displayShapeLayer
  id="shapes"
  data={shapes}
  selectedShapeId={selectedId}
  highlightColor={[255, 0, 0, 128]} // Red at 50% opacity [R, G, B, A]
/>
```

### Hover Effects

When `pickable={true}`, shapes show hover feedback:

- **All shapes (except Points with icons)**: Border/outline width increases by 2 pixels
- **Point shapes with icons**: Coffin corners appear with a white fill and black outline

## Event Bus Integration

The layer automatically emits events via `@accelint/bus`. All events include a required `mapId` field for multi-map isolation.

### shapes:selected

Emitted when a shape is clicked:

```tsx
import { useOn } from '@accelint/bus/react';
import { ShapeEvents, type ShapeSelectedEvent } from '@accelint/map-toolkit/deckgl/shapes/shared/events';

function MyComponent() {
  useOn<ShapeSelectedEvent>(ShapeEvents.selected, (event) => {
    // Filter by map instance ID for multi-map scenarios
    if (event.payload.mapId !== MAP_ID) return;
    console.log('Selected shape ID:', event.payload.shapeId);
  });

  // ...
}
```

### shapes:hovered

Emitted when hovering over a shape (or when hover ends):

```tsx
import { useOn } from '@accelint/bus/react';
import { ShapeEvents, type ShapeHoveredEvent } from '@accelint/map-toolkit/deckgl/shapes/shared/events';
import { useMapCursor } from '@accelint/map-toolkit/map-cursor';

function MyComponent() {
  const { requestCursorChange, clearCursor } = useMapCursor(MAP_ID);

  // Change cursor on shape hover
  useOn<ShapeHoveredEvent>(ShapeEvents.hovered, (event) => {
    if (event.payload.mapId !== MAP_ID) return;

    if (event.payload.shapeId) {
      requestCursorChange('pointer', 'display-shapes');
    } else {
      clearCursor('display-shapes');
    }
  });

  // ...
}
```

### shapes:deselected

Emitted when clicking empty space. **Note:** The layer emits `shapes:selected` automatically, but deselection requires consumer-side wiring. Listen to `MapEvents.click` and emit `shapes:deselected` when clicking empty space:

```tsx
import { useEmit, useOn } from '@accelint/bus/react';
import { ShapeEvents, type ShapeDeselectedEvent } from '@accelint/map-toolkit/deckgl/shapes/shared/events';
import { MapEvents } from '@accelint/map-toolkit/deckgl/base-map/events';

function MyComponent() {
  const emitDeselected = useEmit<ShapeDeselectedEvent>(ShapeEvents.deselected);

  useOn(MapEvents.click, (event) => {
    // If clicked empty space and have selection
    if (selectedId && event.payload.id === MAP_ID && event.payload.info.index === -1) {
      emitDeselected({ mapId: MAP_ID });
    }
  });

  // ...
}
```

## Callbacks

In addition to event bus integration, the layer provides callback props:

### onShapeClick

```tsx
<displayShapeLayer
  id="shapes"
  data={shapes}
  onShapeClick={(shape) => {
    console.log('Clicked:', shape.name);
    // Access full shape data including geometry, properties, etc.
  }}
/>
```

### onShapeHover

```tsx
<displayShapeLayer
  id="shapes"
  data={shapes}
  onShapeHover={(shape) => {
    if (shape) {
      console.log('Hovering:', shape.name);
    } else {
      console.log('Hover ended');
    }
  }}
/>
```

## Icon Atlas Constraint

When using icons for Point geometries, **all shapes in a single DisplayShapeLayer must share the same icon atlas**. The layer uses the first atlas found across all features. If you need icons from different atlases, use separate DisplayShapeLayer instances.

## Performance Considerations

- **Feature caching**: Transformed features are cached and reused when the `data` array reference hasn't changed
- **Label position caching**: Label positions are computed once per shape using a WeakMap cache
- **Hover event deduplication**: The `shapes:hovered` event only emits when the hovered shape actually changes
- **Update triggers**: The layer uses deck.gl's `updateTriggers` to minimize re-renders
- **Icon config extraction**: Icon atlas and mapping are extracted in a single pass with early return (O(1) best case)
- Use `pickable={false}` to disable interaction and improve performance for static displays

## API Reference

### DisplayShapeLayerProps

| Prop | Type | Default | Description |
|------|------|---------|-------------|
| `id` | `string` | *required* | Unique layer ID |
| `mapId` | `UniqueId` | *required* | Map instance ID for event bus isolation in multi-map scenarios |
| `data` | `Shape[]` | *required* | Array of shapes to display |
| `selectedShapeId` | `ShapeId` | `undefined` | Currently selected shape ID for highlighting |
| `onShapeClick` | `(shape: Shape) => void` | `undefined` | Callback when shape is clicked |
| `onShapeHover` | `(shape: Shape \| null) => void` | `undefined` | Callback when shape is hovered |
| `pickable` | `boolean` | `true` | Whether shapes are clickable/hoverable |
| `showLabels` | `boolean` | `true` | Whether to show labels |
| `showHighlight` | `boolean` | `false` | Whether to show highlight around selected shapes (dotted border always shows) |
| `labelOptions` | `LabelPositionOptions` | `undefined` | Global label positioning options |
| `highlightColor` | `[number, number, number, number]` | `[40, 245, 190, 100]` | Highlight color RGBA (0-255) |
| `applyBaseOpacity` | `boolean` | `true` | Apply 20% opacity multiplier to fill colors for semi-transparent look |

### LabelPositionOptions

See the [Label Positioning](#label-positioning) section for detailed documentation on available options for each geometry type.

### useShapeSelection Hook

A companion hook that manages selection state and auto-deselection using a store pattern with `useSyncExternalStore`:

```tsx
import { useShapeSelection } from '@accelint/map-toolkit/deckgl/shapes';

const { selectedId, setSelectedId, clearSelection } = useShapeSelection(mapId);
```

| Return Value | Type | Description |
|--------------|------|-------------|
| `selectedId` | `ShapeId \| undefined` | Currently selected shape ID |
| `setSelectedId` | `(id: ShapeId \| undefined) => void` | Manually set selection (emits events) |
| `clearSelection` | `() => void` | Clear selection (emits deselected event) |

The hook automatically:
- Listens to `shapes:selected` events and updates state
- Listens to `shapes:deselected` events and clears state
- Emits `shapes:deselected` when clicking empty space on the map

**Architecture**: The hook uses a store pattern similar to `useMapCursor` and `useMapMode`. This ensures:
- Only one bus listener per map instance (regardless of how many components subscribe)
- Proper cleanup during HMR (Hot Module Replacement) in development
- Referentially stable function returns to prevent unnecessary re-renders

## Examples

See the Storybook stories for interactive examples:

- **BasicDisplayAndEvents**: Interactive shape display with event logging and `applyBaseOpacity` toggle
- **LabelPositioning**: Comprehensive label positioning controls
- **WithPointIcons**: Custom icon atlas demo
